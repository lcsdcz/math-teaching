<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, orientation=landscape">
  <title>含参函数解析几何教学工具</title>
  <style>
    body { 
      font-family: Arial, sans-serif; 
      background: #f8f8f8; 
      margin:0; 
      touch-action: manipulation;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    .container { 
      display: flex; 
      height: 100vh; 
      min-height: 100vh;
      position: relative;
    }
    .sidebar {
      width: 280px;
      background: #f4f6fa;
      border-right: 1px solid #ddd;
      padding: 12px 8px 8px 12px;
      overflow-y: auto;
      font-size: 14px;
      transition: transform 0.3s ease;
    }
    
    /* 移动端适配 */
    @media screen and (max-width: 768px) {
      .container {
        flex-direction: row;
        position: relative;
      }
      .sidebar {
        width: 240px;
        padding: 8px 6px 6px 8px;
        font-size: 12px;
        z-index: 1000;
        position: absolute;
        left: 0;
        top: 0;
        height: 100vh;
        transform: translateX(-100%);
        box-shadow: 2px 0 10px rgba(0,0,0,0.1);
      }
      .sidebar.show {
        transform: translateX(0);
      }
      .main {
        width: 100%;
        margin-left: 0;
      }
      .toolbar {
        padding: 8px 0 6px 40px !important;
        font-size: 14px;
      }
      .toolbar button {
        font-size: 14px !important;
        padding: 4px 12px !important;
        margin: 0 3px 0 0 !important;
      }
      #canvas {
        margin: 12px auto 0 auto !important;
      }
    }
    
    /* 手机横屏优化 */
    @media screen and (max-width: 768px) and (orientation: landscape) {
      .sidebar {
        width: 220px;
        padding: 6px 4px 4px 6px;
        font-size: 11px;
      }
      .parameter-control {
        padding: 8px !important;
        margin: 4px 0 !important;
      }
      .parameter-item {
        margin: 4px 0 !important;
      }
      .toolbar {
        padding: 6px 0 4px 40px !important;
      }
      .toolbar button {
        font-size: 12px !important;
        padding: 3px 8px !important;
      }
    }
    .sidebar h3 { margin: 10px 0 6px 0; font-size: 18px; color: #3498db; }
    .sidebar ul { list-style: none; padding: 0; margin: 0 0 10px 0; }
    .sidebar li { margin-bottom: 7px; cursor: pointer; padding: 3px 6px; border-radius: 4px; }
    .sidebar li.selected { background: #d0e8ff; color: #217dbb; font-weight: bold; }
    .main { flex: 1; display: flex; flex-direction: column; }
    .toolbar {
      text-align: left;
      padding: 12px 0 8px 30px;
      background: #fff;
      border-bottom: 1px solid #eee;
    }
    .toolbar button {
      font-size: 16px;
      margin: 0 5px 0 0;
      padding: 6px 16px;
    }
    .input-area {
      text-align: left;
      margin: 10px 0 0 30px;
    }
    .input-area input, .input-area button {
      font-size: 16px;
      margin: 0 5px 0 0;
      padding: 6px 10px;
    }
    .active-btn {
      background: #3498db;
      color: #fff;
      border: none;
    }
    #canvas {
      background: #fff;
      border: 1px solid #ccc;
      margin: 18px auto 0 auto;
      box-shadow: 0 2px 8px #ddd;
      display: block;
      cursor: grab;
    }
    .intersection-point { fill: #e67e22; stroke: #d35400; stroke-width: 2px; }
    /* 下拉菜单样式 */
    .dropdown {
      position: relative;
      display: inline-block;
    }
    .dropdown-toggle {
      background-color: #f4f6fa;
      color: #333;
      border: 1px solid #ccc;
      padding: 6px 16px;
      font-size: 16px;
      cursor: pointer;
      border-radius: 4px;
    }
    .dropdown-toggle:hover {
      background-color: #e0e0e0;
    }
    .dropdown-menu {
      position: absolute;
      background-color: #fff;
      min-width: 160px;
      box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
      z-index: 1000;
      border-radius: 4px;
      border: 1px solid #ccc;
    }
    .dropdown-item {
      padding: 12px 16px;
      cursor: pointer;
      color: #333;
      font-size: 14px;
    }
    .dropdown-item:hover {
      background-color: #f0f0f0;
    }
    /* 参数控制样式 */
    .parameter-control {
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 6px;
      padding: 12px;
      margin: 8px 0;
    }
    .parameter-item {
      margin: 8px 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .parameter-item label {
      min-width: 30px;
      font-weight: bold;
      color: #2c3e50;
    }
    .parameter-item input[type="range"] {
      flex: 1;
      height: 6px;
      background: #ddd;
      outline: none;
      border-radius: 3px;
    }
    .parameter-item input[type="number"] {
      width: 60px;
      padding: 4px;
      border: 1px solid #ccc;
      border-radius: 3px;
    }
    .parameter-detected {
      background: #e8f5e8;
      color: #27ae60;
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 4px;
      margin: 4px 0;
    }
    /* 删除按钮样式 */
    .delete-btn {
      background: #e74c3c;
      color: white;
      border: none;
      border-radius: 3px;
      padding: 2px 6px;
      font-size: 12px;
      cursor: pointer;
      margin-left: 8px;
      opacity: 0.7;
      transition: opacity 0.2s;
    }
    .delete-btn:hover {
      opacity: 1;
    }
    .sidebar li {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .sidebar li .item-text {
      flex: 1;
    }
  </style>
</head>
<body>
<div class="container">
  <div class="sidebar">
    <!-- 参数控制区域 -->
    <div class="parameter-control">
      <h3 style="margin: 0 0 8px 0; color: #e74c3c;">参数控制</h3>
      <div id="parameter-list"></div>
      <div style="margin-top: 10px;">
        <button onclick="addCustomParameter()" style="font-size: 14px; padding: 4px 8px;">添加参数</button>
        <button onclick="resetParameters()" style="font-size: 14px; padding: 4px 8px;">重置参数</button>
        <button onclick="restoreOriginalPositions()" style="font-size: 14px; padding: 4px 8px; background: #27ae60; color: white;">复原所有点</button>
      </div>
    </div>
    
    <!-- 数学常数说明 -->
    <div style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 6px; padding: 12px; margin: 8px 0; font-size: 13px; color: #856404;">
      <div style="font-weight: bold; margin-bottom: 6px;">📚 数学常数说明</div>
      <div style="margin-bottom: 4px;">• <strong>e</strong> = 2.71828... (自然对数的底数)</div>
      <div style="margin-bottom: 4px;">• <strong>π</strong> 或 <strong>pi</strong> = 3.14159... (圆周率)</div>
      <div style="color: #27ae60; font-weight: bold;">✅ 这些数学常数会被自动识别，不会误认为参数</div>
      <div style="color: #e74c3c; font-weight: bold;">⚠️ 注意：sin, cos, tan, exp, log 等函数名也不会被识别为参数</div>
    </div>
    
    <h3>点</h3>
    <ul id="point-list"></ul>
    <h3>线段/直线</h3>
    <ul id="segment-list"></ul>
    <h3>直线</h3>
    <ul id="line-list"></ul>
    <h3>圆</h3>
    <ul id="circle-list"></ul>
    <h3>函数/方程</h3>
    <ul id="function-list"></ul>
  </div>
  <div class="main">
    <div class="toolbar">
      <button id="btn-move" onclick="switchMode('move')">移动画布</button>
      <button id="btn-drag" onclick="switchMode('drag')">拖动对象</button>
      <button id="btn-point" onclick="switchMode('point')">点</button>
      <button id="btn-segment" onclick="switchMode('segment')">线段</button>
      <div class="dropdown" style="display:inline-block;position:relative;">
        <button id="btn-function" class="dropdown-toggle active-btn" onclick="toggleFunctionMenu()">含参函数▼</button>
        <div class="dropdown-menu" id="function-menu" style="display:none;position:absolute;left:0;top:36px;background:#fff;border:1px solid #ccc;border-radius:6px;box-shadow:0 2px 8px #eee;z-index:10;min-width:120px;">
          <div class="dropdown-item" data-type="circle">圆</div>
          <div class="dropdown-item" data-type="ellipse">椭圆</div>
          <div class="dropdown-item" data-type="parabola">抛物线</div>
          <div class="dropdown-item" data-type="hyperbola">双曲线</div>
          <div class="dropdown-item" data-type="equation">直接输入方程</div>
          <div class="dropdown-item" data-type="polar">极坐标</div>
        </div>
      </div>
      <button id="btn-line" onclick="switchMode('line')">作直线</button>
      <button onclick="resetAll()">重置</button>
    </div>
    <div class="input-area" id="input-area"></div>
    <div id="function-type-label" style="margin-left:30px;margin-top:8px;font-size:17px;color:#217dbb;"></div>
    <div id="parameter-hint" style="margin-left:30px;margin-top:4px;font-size:14px;color:#7f8c8d;"></div>
    <div style="position:relative;flex:1;">
      <canvas id="canvas" width="900" height="600"></canvas>
      <button id="reset-view-btn" title="视角复位" style="position:absolute;top:12px;right:18px;z-index:1001;background:#fff;border:1px solid #ccc;border-radius:6px;padding:4px 12px;font-size:15px;cursor:pointer;">视角复位</button>
      <div style="position:absolute;right:18px;bottom:12px;font-size:15px;background:rgba(255,255,255,0.8);padding:4px 10px;border-radius:6px;">
        <label><input type="checkbox" id="toggle-grid" checked onchange="toggleGrid()"> 显示网格</label>
      </div>
    </div>
    <button id="fullscreen-btn" title="全屏" style="position:fixed;top:16px;right:24px;z-index:1000;background:#fff;border:1px solid #ccc;border-radius:6px;padding:6px 14px;font-size:18px;cursor:pointer;transition:box-shadow 0.2s;">⛶</button>
    <button id="export-image-btn" title="导出为图片" style="position:fixed;top:16px;right:180px;z-index:1000;background:#fff;border:1px solid #ccc;border-radius:6px;padding:6px 10px;font-size:14px;cursor:pointer;transition:box-shadow 0.2s;">导出图片</button>
    <select id="export-bg-select" title="导出背景" style="position:fixed;top:16px;right:110px;z-index:1000;background:#fff;border:1px solid #ccc;border-radius:6px;padding:6px 6px;font-size:14px;cursor:pointer;">
      <option value="white">白底</option>
      <option value="transparent">透明</option>
    </select>
    <button class="mobile-menu-btn" onclick="toggleMobileMenu()">☰ 菜单</button>
    <div class="mobile-overlay" onclick="hideMobileMenu()"></div>
    <style>
    #fullscreen-btn:hover { box-shadow:0 2px 8px #aaa; }
    
    /* 移动端菜单按钮 */
    .mobile-menu-btn {
      display: none;
      position: fixed;
      top: 16px;
      left: 16px;
      z-index: 1001;
      background: #3498db;
      color: white;
      border: none;
      border-radius: 6px;
      padding: 8px 12px;
      font-size: 14px;
      cursor: pointer;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      touch-action: manipulation;
    }
    
    @media screen and (max-width: 768px) {
      .mobile-menu-btn {
        display: block;
      }
    }
    
    /* 移动端遮罩 */
    .mobile-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.3);
      z-index: 999;
    }
    
    .mobile-overlay.show {
      display: block;
    }
    </style>
  </div>
</div>
<script>
// 数据结构
let points = [];
let segments = [];
let circles = [];
let functions = [];
let intersectionPoints = [];
let intersectionLines = [];
let draggingPoint = null;
let dragOffset = {x:0, y:0};
let mode = 'point';
let tempSegment = [];
let tempCircle = [];
let tempLine = [];
let clickAddPointMode = false;
let selectedPointIdx = null;
let selectedSegmentIdx = null;
let selectedCircleIdx = null;
let selectedFunctionIdx = null;
let selectedEllipseIdx = null;
let selectedParabolaIdx = null;
let selectedHyperbolaIdx = null;
let selectedPolarIdx = null;
let draggingCurve = null;
let curveType = null;
let lineSelectPoints = [];
let lineSelectActive = false;
let ellipses = [];
let parabolas = [];
let hyperbolas = [];
let polars = [];

// 参数系统
let parameters = {}; // 存储所有参数 {name: value}
let parameterRanges = {}; // 存储参数范围 {name: {min, max, step}}

// 撤销系统
let operationHistory = []; // 操作历史
const maxHistorySize = 50; // 最大历史记录数

// 坐标系平移/缩放
let draggingCanvas = false;
let scalingCanvas = false;
let panOffset = {x: 0, y: 0}; // 视图平移量，单位：数学坐标
let lastMouse = {x: 0, y: 0};
let scale = 40; // 初始缩放比例
// 无限缩放，不再限制 minScale/maxScale
// const minScale = 10, maxScale = 200;
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const width = canvas.width;
const height = canvas.height;
let origin = { x: width/2, y: height/2 };
let showGrid = true;

// 全局变量：是否跳过删除确认
let skipDeleteConfirm = false;

// 参数管理函数
function extractParameters(text) {
  if (!text) return [];
  
  // 首先替换掉数学常数，避免它们被误识别为参数
  let processedText = text.toString()
    .replace(/\bpi\b/gi, '3.14159')  // 替换pi为数字
    .replace(/\bπ\b/g, '3.14159')    // 替换π为数字
    .replace(/\be\b/g, '2.71828');   // 替换e为数字
  
  // 排除常用变量和函数名
  const exclude = ['x', 'y', 'r', 'theta', 'th', 'sin', 'cos', 'tan', 'exp', 'log', 'ln', 'abs'];
  const params = [];
  
  // 匹配所有字母
  const matches = processedText.match(/[a-zA-Z]/g) || [];
  matches.forEach(ch => {
    const lower = ch.toLowerCase();
    if (!exclude.includes(lower) && !params.includes(ch)) {
      params.push(ch);
    }
  });
  return params;
}

// 测试函数 - 可以在浏览器控制台调用
function testParameterExtraction() {
  console.log('测试参数提取：');
  console.log('pi -> ', extractParameters('pi'));
  console.log('pi*r -> ', extractParameters('pi*r'));
  console.log('2*pi*r -> ', extractParameters('2*pi*r'));
  console.log('a*pi + b -> ', extractParameters('a*pi + b'));
  console.log('sin(pi/4) -> ', extractParameters('sin(pi/4)'));
}

function testParameterSubstitution() {
  console.log('测试参数替换：');
  console.log('pi -> ', substituteParameters('pi'));
  console.log('2*pi -> ', substituteParameters('2*pi'));
  console.log('pi*2 -> ', substituteParameters('pi*2'));
  parameters.r = 5;
  console.log('pi*r (r=5) -> ', substituteParameters('pi*r'));
}

// 从拖动的点反向计算参数值
function updateParametersFromPoint(point) {
  if (!point.xExpr || !point.yExpr) return;
  
  // 尝试解析简单的参数表达式
  const xParams = extractParameters(point.xExpr);
  const yParams = extractParameters(point.yExpr);
  
  // 对于简单情况，如果表达式就是单个参数，直接更新
  if (xParams.length === 1 && point.xExpr.trim() === xParams[0]) {
    parameters[xParams[0]] = point.x;
  }
  if (yParams.length === 1 && point.yExpr.trim() === yParams[0]) {
    parameters[yParams[0]] = point.y;
  }
  
  // 重新渲染参数控制区域
  renderParameterControls();
}

// 复原所有点到原始位置
function restoreOriginalPositions() {
  if (confirm('确定要复原所有点到初始状态吗？这将重置所有拖动的修改。')) {
    saveState(); // 保存状态用于撤销
    
    points.forEach(point => {
      point.isDragged = false;
      // 重新计算参数化点的位置
      if (point.xExpr && point.yExpr) {
        try {
          point.x = eval(substituteParameters(point.xExpr));
          point.y = eval(substituteParameters(point.yExpr));
        } catch (e) {
          // 如果计算失败，保持当前位置
        }
      }
    });
    
    // 复原所有抛物线
    parabolas.forEach(parabola => {
      if (parabola.originalState) {
        parabola.p = parabola.originalState.p;
        parabola.pExpr = parabola.originalState.pExpr;
        parabola.raw = parabola.originalState.raw;
        parabola.isDragged = false;
        parabola.dragOffset = null;
        parabola.transformedEquation = null;
      }
    });
    
    updateIntersections();
    redraw();
  }
}

// 复原单个点
function restorePoint(index) {
  if (index >= 0 && index < points.length) {
    saveState(); // 保存状态用于撤销
    
    const point = points[index];
    point.isDragged = false;
    
    // 重新计算参数化点的位置
    if (point.xExpr && point.yExpr) {
      try {
        point.x = eval(substituteParameters(point.xExpr));
        point.y = eval(substituteParameters(point.yExpr));
      } catch (e) {
        // 如果计算失败，保持当前位置
      }
    }
    
    updateIntersections();
    redraw();
  }
}

// 复原单个抛物线
function restoreParabola(index) {
  if (index >= 0 && index < parabolas.length) {
    saveState(); // 保存状态用于撤销
    
    const parabola = parabolas[index];
    if (parabola.originalState) {
      parabola.p = parabola.originalState.p;
      parabola.pExpr = parabola.originalState.pExpr;
      parabola.raw = parabola.originalState.raw;
      parabola.isDragged = false;
      parabola.dragOffset = null;
      parabola.transformedEquation = null;
    }
    
    redraw();
  }
}

// 键盘控制移动抛物线
function moveParabola(index, dx, dy) {
  if (index >= 0 && index < parabolas.length) {
    const parabola = parabolas[index];
    
    // 确保有初始状态记录
    if (!parabola.originalState) {
      parabola.originalState = {
        p: parabola.p,
        pExpr: parabola.pExpr,
        type: parabola.type,
        raw: parabola.raw
      };
    }
    
    // 初始化或更新拖动偏移
    if (!parabola.dragOffset) {
      parabola.dragOffset = {x: 0, y: 0};
    }
    
    parabola.dragOffset.x += dx;
    parabola.dragOffset.y += dy;
    parabola.isDragged = true;
    
    // 生成平移后的方程
    generateTransformedEquation(parabola);
  }
}

// 键盘控制移动点
function movePoint(index, dx, dy) {
  if (index >= 0 && index < points.length) {
    const point = points[index];
    point.x += dx;
    point.y += dy;
    point.isDragged = true;
    
    // 如果是参数化的点，更新对应的参数值
    if (point.xExpr && point.yExpr) {
      updateParametersFromPoint(point);
    }
    
    // 更新相关的圆
    for(let c of circles) {
      if(c.centerRef === point) {
        c.x = point.x;
        c.y = point.y;
      }
    }
    
    updateIntersections();
  }
}

// 生成平移后的方程
function generateTransformedEquation(curve) {
  if (!curve.dragOffset) return;
  
  const dx = curve.dragOffset.x;
  const dy = curve.dragOffset.y;
  
  if (curve.type === 'y2') {
    // 原方程：y²=2px，平移后：(y-k)²=2p(x-h)
    let pValue = curve.pExpr || curve.p;
    
    // 构建平移后的方程
    let equation = '';
    
    // 处理 y 项
    if (Math.abs(dy) < 0.01) {
      equation += 'y²';
    } else if (dy > 0) {
      equation += `(y-${dy.toFixed(1)})²`;
    } else {
      equation += `(y+${Math.abs(dy).toFixed(1)})²`;
    }
    
    equation += '=';
    
    // 处理 x 项
    if (typeof pValue === 'string') {
      equation += `2*${pValue}*`;
    } else {
      equation += `${(2*pValue).toFixed(1)}*`;
    }
    
    if (Math.abs(dx) < 0.01) {
      equation += 'x';
    } else if (dx > 0) {
      equation += `(x-${dx.toFixed(1)})`;
    } else {
      equation += `(x+${Math.abs(dx).toFixed(1)})`;
    }
    
    curve.transformedEquation = equation;
    
  } else if (curve.type === 'x2') {
    // 原方程：x²=2py，平移后：(x-h)²=2p(y-k)
    let pValue = curve.pExpr || curve.p;
    
    let equation = '';
    
    // 处理 x 项
    if (Math.abs(dx) < 0.01) {
      equation += 'x²';
    } else if (dx > 0) {
      equation += `(x-${dx.toFixed(1)})²`;
    } else {
      equation += `(x+${Math.abs(dx).toFixed(1)})²`;
    }
    
    equation += '=';
    
    // 处理 y 项
    if (typeof pValue === 'string') {
      equation += `2*${pValue}*`;
    } else {
      equation += `${(2*pValue).toFixed(1)}*`;
    }
    
    if (Math.abs(dy) < 0.01) {
      equation += 'y';
    } else if (dy > 0) {
      equation += `(y-${dy.toFixed(1)})`;
    } else {
      equation += `(y+${Math.abs(dy).toFixed(1)})`;
    }
    
    curve.transformedEquation = equation;
  }
}

// 椭圆： (x-h)^2/a^2 + (y-k)^2/b^2 = 1
function generateTransformedEquationEllipse(e) {
  const dx = (e.dragOffset && e.dragOffset.x) || 0;
  const dy = (e.dragOffset && e.dragOffset.y) || 0;
  const x0 = (typeof e.x === 'number') ? e.x : 0;
  const y0 = (typeof e.y === 'number') ? e.y : 0;
  const a = e.a;
  const b = e.b;
  const cx = (x0 + dx).toFixed(1);
  const cy = (y0 + dy).toFixed(1);
  const a2 = (a*a).toFixed(1);
  const b2 = (b*b).toFixed(1);
  e.transformedEquation = `(x-${cx})^2/${a2} + (y-${cy})^2/${b2} = 1`;
}

// 圆： (x-h)^2 + (y-k)^2 = r^2
function generateTransformedEquationCircle(c) {
  const dx = (c.dragOffset && c.dragOffset.x) || 0;
  const dy = (c.dragOffset && c.dragOffset.y) || 0;
  const x0 = (typeof c.x === 'number') ? c.x : 0;
  const y0 = (typeof c.y === 'number') ? c.y : 0;
  const r2 = (c.r*c.r).toFixed(1);
  const cx = (x0 + dx).toFixed(1);
  const cy = (y0 + dy).toFixed(1);
  c.transformedEquation = `(x-${cx})^2 + (y-${cy})^2 = ${r2}`;
}

// 双曲线： 根据方向
function generateTransformedEquationHyperbola(hb) {
  const dx = (hb.dragOffset && hb.dragOffset.x) || 0;
  const dy = (hb.dragOffset && hb.dragOffset.y) || 0;
  const x0 = (typeof hb.x === 'number') ? hb.x : 0;
  const y0 = (typeof hb.y === 'number') ? hb.y : 0;
  const a2 = (hb.a*hb.a).toFixed(1);
  const b2 = (hb.b*hb.b).toFixed(1);
  const cx = (x0 + dx).toFixed(1);
  const cy = (y0 + dy).toFixed(1);
  if (hb.dir === 'x') {
    hb.transformedEquation = `(x-${cx})^2/${a2} - (y-${cy})^2/${b2} = 1`;
  } else {
    hb.transformedEquation = `(y-${cy})^2/${a2} - (x-${cx})^2/${b2} = 1`;
  }
}

// 一般函数：输出平移后的解析式（保持原有"y="或"x="的形式）
function generateTransformedEquationFunction(f) {
  const dx = (f.dragOffset && f.dragOffset.x) || 0;
  const dy = (f.dragOffset && f.dragOffset.y) || 0;
  const h = +dx.toFixed(1);
  const k = +dy.toFixed(1);
  const raw = (f.raw || '').trim();

  // 帮助函数：格式化带符号的常数，0 则为空
  const signed = (v) => {
    if (Math.abs(v) < 1e-9) return '';
    return (v > 0 ? ' + ' : ' - ') + Math.abs(v).toFixed(1);
  };

  // y = g(x)
  if (/^y\s*=/.test(raw)) {
    let rhs = raw.replace(/^y\s*=\s*/, '');
    // 将所有 x 替换为 (x-h)
    const hStr = (Math.abs(h) < 1e-9) ? 'x' : `(x-${h.toFixed(1)})`;
    // 注意：避免替换函数名里的 x，例如 max、exp；使用\bx\b 边界
    rhs = rhs.replace(/\bx\b/g, hStr);
    // y 平移增加 k
    f.transformedEquation = `y = ${rhs}${signed(k)}`;
    return;
  }

  // x = g(y)
  if (/^x\s*=/.test(raw)) {
    let rhs = raw.replace(/^x\s*=\s*/, '');
    const kStr = (Math.abs(k) < 1e-9) ? 'y' : `(y-${k.toFixed(1)})`;
    rhs = rhs.replace(/\by\b/g, kStr);
    f.transformedEquation = `x = ${rhs}${signed(h)}`;
    return;
  }

  // 其他情况，默认按 y = expr 处理
  if (raw) {
    let rhs = raw;
    const hStr = (Math.abs(h) < 1e-9) ? 'x' : `(x-${h.toFixed(1)})`;
    rhs = rhs.replace(/\bx\b/g, hStr);
    f.transformedEquation = `y = ${rhs}${signed(k)}`;
    return;
  }

  // 如果无 raw，则回退
  f.transformedEquation = null;
}

// 极坐标：标注笛卡尔平移规则
function generateTransformedEquationPolar(p) {
  const dx = (p.dragOffset && p.dragOffset.x) || 0;
  const dy = (p.dragOffset && p.dragOffset.y) || 0;
  const h = dx.toFixed(1);
  const k = dy.toFixed(1);
  p.transformedEquation = `x = r(θ)cosθ ${dx>=0?'+':'-'} ${Math.abs(h)}, y = r(θ)sinθ ${dy>=0?'+':'-'} ${Math.abs(k)}`;
}

function addParameter(name, value = 1, min = -10, max = 10, step = 0.1) {
  if (!parameters.hasOwnProperty(name)) {
    parameters[name] = value;
    parameterRanges[name] = {min, max, step};
    renderParameterControls();
  }
}

function updateParameter(name, value) {
  if (parameters.hasOwnProperty(name)) {
    parameters[name] = parseFloat(value);
    redraw();
  }
}

function resetParameters() {
  parameters = {};
  parameterRanges = {};
  renderParameterControls();
  redraw();
}

function addCustomParameter() {
  const name = prompt("请输入参数名称（单个字母，如 a, b, m, n 等）:");
  if (name && /^[a-zA-Z]$/.test(name)) {
    const value = parseFloat(prompt("请输入初始值:", "1")) || 1;
    addParameter(name, value);
  } else if (name) {
    alert("参数名称必须是单个字母！");
  }
}

function substituteParameters(expr) {
  if (!expr) return expr;
  let result = expr.toString();
  
  // 先替换数学常数，避免被后续处理影响
  result = result.replace(/\bpi\b/gi, 'Math.PI');
  result = result.replace(/\bπ\b/g, 'Math.PI');
  result = result.replace(/\be\b/g, 'Math.E');
  
  // 处理乘法简写（如 5m -> 5*m），但要避免影响Math.PI
  result = result.replace(/(\d+)([a-zA-Z])/g, '$1*$2');
  // 处理相邻字母（如 mn -> m*n），但要保护Math.PI
  result = result.replace(/([a-zA-Z])([a-zA-Z])/g, function(match, p1, p2) {
    // 如果是Math.PI的一部分，不要拆分
    if (match === 'th' || match === 'Ma' || match === 'at' || match === 'PI') {
      return match;
    }
    return p1 + '*' + p2;
  });
  
  for (let [name, value] of Object.entries(parameters)) {
    // 使用正则表达式替换参数，确保不会替换函数名的一部分
    const regex = new RegExp('\\b' + name + '\\b', 'g');
    result = result.replace(regex, value.toString());
  }
  return result;
}

function renderParameterControls() {
  const container = document.getElementById('parameter-list');
  container.innerHTML = '';
  
  if (Object.keys(parameters).length === 0) {
    container.innerHTML = '<div style="color:#999;font-size:13px;">暂无参数</div>';
    return;
  }
  
  for (let [name, value] of Object.entries(parameters)) {
    const range = parameterRanges[name];
    const div = document.createElement('div');
    div.className = 'parameter-item';
    div.innerHTML = `
      <label>${name}:</label>
      <input type="range" 
             min="${range.min}" 
             max="${range.max}" 
             step="${range.step}" 
             value="${value}"
             oninput="updateParameter('${name}', this.value); document.getElementById('param-${name}-value').value = this.value">
      <input type="number" 
             id="param-${name}-value"
             min="${range.min}" 
             max="${range.max}" 
             step="${range.step}" 
             value="${value}"
             oninput="updateParameter('${name}', this.value); this.previousElementSibling.value = this.value"
             onchange="updateParameter('${name}', this.value); this.previousElementSibling.value = this.value">
      <button onclick="resetParameter('${name}')" style="padding:2px 6px;font-size:12px;">重置</button>
      <button onclick="removeParameter('${name}')" style="padding:2px 6px;font-size:12px;">×</button>
    `;
    container.appendChild(div);
  }
}

function removeParameter(name) {
  delete parameters[name];
  delete parameterRanges[name];
  renderParameterControls();
  redraw();
}

function detectAndAddParameters(inputs) {
  const detectedParams = [];
  inputs.forEach(input => {
    if (typeof input === 'string') {
      const params = extractParameters(input);
      params.forEach(param => {
        if (!parameters.hasOwnProperty(param)) {
          addParameter(param);
          detectedParams.push(param);
        }
      });
    }
  });
  
  if (detectedParams.length > 0) {
    document.getElementById('parameter-hint').innerHTML = 
      `<div class="parameter-detected">检测到新参数: ${detectedParams.join(', ')}</div>`;
    setTimeout(() => {
      document.getElementById('parameter-hint').innerHTML = '';
    }, 3000);
  }
}

// 撤销系统函数
function saveState() {
  const state = {
    points: JSON.parse(JSON.stringify(points)),
    segments: JSON.parse(JSON.stringify(segments)),
    circles: JSON.parse(JSON.stringify(circles)),
    ellipses: JSON.parse(JSON.stringify(ellipses)),
    parabolas: JSON.parse(JSON.stringify(parabolas)),
    hyperbolas: JSON.parse(JSON.stringify(hyperbolas)),
    polars: JSON.parse(JSON.stringify(polars)),
    functions: JSON.parse(JSON.stringify(functions)),
    intersectionPoints: JSON.parse(JSON.stringify(intersectionPoints)),
    intersectionLines: JSON.parse(JSON.stringify(intersectionLines)),
    parameters: JSON.parse(JSON.stringify(parameters)),
    parameterRanges: JSON.parse(JSON.stringify(parameterRanges))
  };
  
  operationHistory.push(state);
  if (operationHistory.length > maxHistorySize) {
    operationHistory.shift();
  }
}

function undo() {
  if (operationHistory.length > 0) {
    const state = operationHistory.pop();
    points = state.points;
    segments = state.segments;
    circles = state.circles;
    ellipses = state.ellipses;
    parabolas = state.parabolas;
    hyperbolas = state.hyperbolas;
    polars = state.polars;
    functions = state.functions;
    intersectionPoints = state.intersectionPoints;
    intersectionLines = state.intersectionLines;
    parameters = state.parameters;
    parameterRanges = state.parameterRanges;
    
    renderParameterControls();
    redraw();
  }
}

// 删除函数
function deletePoint(index) {
  if (skipDeleteConfirm) {
    doDeletePoint(index);
    return;
  }
  showDeleteConfirm('删除此点会同时删除相关的线段和直线，确定要删除吗？', function(checked) {
    if (checked) skipDeleteConfirm = true;
    doDeletePoint(index);
  });
}

function doDeletePoint(index) {
  saveState();
  const pointToDelete = points[index];
  segments = segments.filter(seg => seg.p1 !== pointToDelete && seg.p2 !== pointToDelete);
  intersectionLines = intersectionLines.filter(line => line.p1 !== pointToDelete && line.p2 !== pointToDelete);
  circles = circles.filter(c => c.centerRef !== pointToDelete);
  points.splice(index, 1);
  selectedPointIdx = null;
  updateIntersections();
  redraw();
}

function deleteSegment(index) {
  if (skipDeleteConfirm) {
    doDeleteSegment(index);
    return;
  }
  showDeleteConfirm('确定要删除此线段吗？', function(checked) {
    if (checked) skipDeleteConfirm = true;
    doDeleteSegment(index);
  });
}

function doDeleteSegment(index) {
  saveState();
  segments.splice(index, 1);
  updateIntersections();
  redraw();
}

function deleteLine(index) {
  if (skipDeleteConfirm) {
    doDeleteLine(index);
    return;
  }
  showDeleteConfirm('确定要删除此直线吗？', function(checked) {
    if (checked) skipDeleteConfirm = true;
    doDeleteLine(index);
  });
}

function doDeleteLine(index) {
  saveState();
  intersectionLines.splice(index, 1);
  redraw();
}

function deleteCircle(index) {
  if (skipDeleteConfirm) {
    doDeleteCircle(index);
    return;
  }
  showDeleteConfirm('确定要删除此圆吗？', function(checked) {
    if (checked) skipDeleteConfirm = true;
    doDeleteCircle(index);
  });
}

function doDeleteCircle(index) {
  saveState();
  circles.splice(index, 1);
  updateIntersections();
  redraw();
}

function deleteFunction(index) {
  if (skipDeleteConfirm) {
    doDeleteFunction(index);
    return;
  }
  showDeleteConfirm('确定要删除此函数吗？', function(checked) {
    if (checked) skipDeleteConfirm = true;
    doDeleteFunction(index);
  });
}

function doDeleteFunction(index) {
  saveState();
  functions.splice(index, 1);
  updateIntersections();
  redraw();
}

function deleteEllipse(index) {
  if (skipDeleteConfirm) {
    doDeleteEllipse(index);
    return;
  }
  showDeleteConfirm('确定要删除此椭圆吗？', function(checked) {
    if (checked) skipDeleteConfirm = true;
    doDeleteEllipse(index);
  });
}

function doDeleteEllipse(index) {
  saveState();
  ellipses.splice(index, 1);
  redraw();
}

function deleteParabola(index) {
  if (skipDeleteConfirm) {
    doDeleteParabola(index);
    return;
  }
  showDeleteConfirm('确定要删除此抛物线吗？', function(checked) {
    if (checked) skipDeleteConfirm = true;
    doDeleteParabola(index);
  });
}

function doDeleteParabola(index) {
  saveState();
  parabolas.splice(index, 1);
  redraw();
}

function deleteHyperbola(index) {
  if (skipDeleteConfirm) {
    doDeleteHyperbola(index);
    return;
  }
  showDeleteConfirm('确定要删除此双曲线吗？', function(checked) {
    if (checked) skipDeleteConfirm = true;
    doDeleteHyperbola(index);
  });
}

function doDeleteHyperbola(index) {
  saveState();
  hyperbolas.splice(index, 1);
  redraw();
}

function deletePolar(index) {
  if (skipDeleteConfirm) {
    doDeletePolar(index);
    return;
  }
  showDeleteConfirm('确定要删除此极坐标曲线吗？', function(checked) {
    if (checked) skipDeleteConfirm = true;
    doDeletePolar(index);
  });
}

function doDeletePolar(index) {
  saveState();
  polars.splice(index, 1);
  redraw();
}

// 通用删除确认弹窗
function showDeleteConfirm(msg, callback) {
  // 创建遮罩
  let mask = document.createElement('div');
  mask.style.position = 'fixed';
  mask.style.left = '0';
  mask.style.top = '0';
  mask.style.width = '100vw';
  mask.style.height = '100vh';
  mask.style.background = 'rgba(0,0,0,0.08)';
  mask.style.zIndex = 9999;
  // 创建弹窗
  let box = document.createElement('div');
  box.style.position = 'fixed';
  box.style.left = '50%';
  box.style.top = '20%';
  box.style.transform = 'translate(-50%, 0)';
  box.style.background = '#fff';
  box.style.borderRadius = '8px';
  box.style.boxShadow = '0 4px 24px #aaa';
  box.style.padding = '28px 32px 18px 32px';
  box.style.minWidth = '320px';
  box.style.textAlign = 'center';
  box.style.zIndex = 10000;
  box.innerHTML = `
    <div style="font-size:18px;font-weight:bold;margin-bottom:10px;">删除确认</div>
    <div style="font-size:15px;margin-bottom:18px;">${msg}</div>
    <label style="font-size:14px;display:inline-flex;align-items:center;gap:4px;margin-bottom:10px;">
      <input type="checkbox" id="skip-delete-confirm"> 之后不再提示
    </label><br>
    <button id="delete-confirm-ok" style="font-size:15px;padding:4px 18px;margin-right:16px;">确定</button>
    <button id="delete-confirm-cancel" style="font-size:15px;padding:4px 18px;">取消</button>
  `;
  document.body.appendChild(mask);
  document.body.appendChild(box);
  document.getElementById('delete-confirm-ok').onclick = function() {
    let checked = document.getElementById('skip-delete-confirm').checked;
    document.body.removeChild(mask);
    document.body.removeChild(box);
    callback(checked);
  };
  document.getElementById('delete-confirm-cancel').onclick = function() {
    document.body.removeChild(mask);
    document.body.removeChild(box);
  };
}

function switchMode(m) {
  mode = m;
  document.querySelectorAll('.toolbar button').forEach(btn=>btn.classList.remove('active-btn'));
  if(document.getElementById('btn-' + m))
    document.getElementById('btn-' + m).classList.add('active-btn');
  tempSegment = [];
  tempCircle = [];
  tempLine = [];
  // 作直线模式初始化
  if(m === 'line') {
    lineSelectPoints = [];
    lineSelectActive = true;
  } else {
    lineSelectPoints = [];
    lineSelectActive = false;
  }
  renderInputArea();
  if(mode==='move') {
    canvas.style.cursor = 'grab';
  } else if(mode==='drag') {
    canvas.style.cursor = 'pointer';
  } else if(mode==='point') {
    canvas.style.cursor = 'crosshair';
  } else if(mode==='line') {
    canvas.style.cursor = 'pointer';
  } else {
    canvas.style.cursor = 'default';
  }
}

// 下拉菜单逻辑
let functionType = 'equation';
document.addEventListener('click', function(e) {
  if(!e.target.closest('.dropdown')) {
    document.getElementById('function-menu').style.display = 'none';
  }
});

function toggleFunctionMenu() {
  const menu = document.getElementById('function-menu');
  menu.style.display = (menu.style.display==='block') ? 'none' : 'block';
}

document.querySelectorAll('#function-menu .dropdown-item').forEach(item => {
  item.onclick = function(e) {
    functionType = this.getAttribute('data-type');
    document.getElementById('function-menu').style.display = 'none';
    switchMode('function');
    renderInputArea();
  };
});

function renderInputArea() {
  const area = document.getElementById('input-area');
  const label = document.getElementById('function-type-label');
  // 新增：类型中文名映射
  const typeMap = {
    'circle': '圆',
    'ellipse': '椭圆',
    'parabola': '抛物线',
    'hyperbola': '双曲线',
    'polar': '极坐标',
    'equation': '方程/函数'
  };
  if(mode==='function') {
    label.textContent = '当前类型：含参' + (typeMap[functionType] || '方程/函数');
  } else {
    label.textContent = '';
  }
  
  if(mode==='point') {
    area.innerHTML = `
      <input id="input-x" type="text" placeholder="x坐标 (可用参数、e、π/pi)" style="width:100px;">
      <input id="input-y" type="text" placeholder="y坐标 (可用参数、e、π/pi)" style="width:100px;">
      <button onclick="addPointByInput()">添加点</button>
    `;
  } else if(mode==='segment') {
    area.innerHTML = `
      <input id="input-x1" type="text" placeholder="x₁ (可用参数、e、π)" style="width:80px;">
      <input id="input-y1" type="text" placeholder="y₁ (可用参数、e、π)" style="width:80px;">
      <input id="input-x2" type="text" placeholder="x₂ (可用参数、e、π)" style="width:80px;">
      <input id="input-y2" type="text" placeholder="y₂ (可用参数、e、π)" style="width:80px;">
      <button onclick="addSegmentByInput()">添加线段</button>
    `;
  } else if(mode==='function') {
    if(functionType==='circle') {
      area.innerHTML = `
        <input id="input-x" type="text" placeholder="圆心x (可用参数、e、π)" style="width:120px;">
        <input id="input-y" type="text" placeholder="圆心y (可用参数、e、π)" style="width:120px;">
        <input id="input-r" type="text" placeholder="半径 (可用参数、e、π)" style="width:120px;">
        <button onclick="addCircleByInput()">添加圆</button>
      `;
    } else if(functionType==='ellipse') {
      area.innerHTML = `
        <input id="input-x" type="text" placeholder="中心x (可用参数、e、π)" style="width:100px;">
        <input id="input-y" type="text" placeholder="中心y (可用参数、e、π)" style="width:100px;">
        <input id="input-a" type="text" placeholder="a (可用参数、e、π)" style="width:100px;">
        <input id="input-b" type="text" placeholder="b (可用参数、e、π)" style="width:100px;">
        <button onclick="addEllipseByInput()">添加椭圆</button>
      `;
    } else if(functionType==='parabola') {
      area.innerHTML = `
        <select id="parabola-type" style="width:90px;">
          <option value="y2">y²=2px</option>
          <option value="x2">x²=2py</option>
        </select>
        <input id="input-p" type="text" placeholder="p (可用参数、e、π)" style="width:100px;">
        <button onclick="addParabolaByInput()">添加抛物线</button>
      `;
    } else if(functionType==='hyperbola') {
      area.innerHTML = `
        <input id="input-x" type="text" placeholder="中心x (可用参数、e、π)" style="width:100px;">
        <input id="input-y" type="text" placeholder="中心y (可用参数、e、π)" style="width:100px;">
        <input id="input-a" type="text" placeholder="a (可用参数、e、π)" style="width:100px;">
        <input id="input-b" type="text" placeholder="b (可用参数、e、π)" style="width:100px;">
        <select id="hyperbola-type" style="width:90px;">
          <option value="x">x轴方向</option>
          <option value="y">y轴方向</option>
        </select>
        <button onclick="addHyperbolaByInput()">添加双曲线</button>
      `;
    } else if(functionType==='polar') {
      area.innerHTML = `
        <input id="input-polar" type="text" placeholder="如 r=a+b*sin(c*theta) (可用e、π)" style="width:280px;">
        <button onclick="addPolarByInput()">绘制极坐标曲线</button>
      `;
    } else {
      area.innerHTML = `
        <input id="input-func" type="text" placeholder="如 y=a*x^2+b 或 x^2/a+y^2/b=1 (可用e、π)" style="width:300px;">
        <button onclick="addFunction()">绘制方程</button>
      `;
    }
  } else if(mode==='line') {
    let btns = '';
    if(lineSelectPoints.length === 2) {
      btns = `<button onclick="confirmLine()">确定</button> <button onclick="cancelLineSelect()">取消</button>`;
    } else if(lineSelectPoints.length === 1) {
      btns = `<button onclick="cancelLineSelect()">取消</button>`;
    }
    area.innerHTML = `<span>依次点击两个点（高亮）作直线</span> ${btns}`;
      } else if(mode==='move') {
      area.innerHTML = `<div style='color:#888;font-size:15px;margin:8px 0 0 0;'>提示：拖动可移动画布视角，滚轮或按住 <b>Shift</b> 拖动可缩放</div>`;
    } else if(mode==='drag') {
      area.innerHTML = `<div style='color:#888;font-size:15px;margin:8px 0 0 0;'>提示：点击选中要拖动的点或几何对象，然后拖动改变位置，也可以使用小键盘上下左右按键移动</div>`;
    }
}

function toggleClickAddPoint() {
  // 该函数已废弃，无需实现
}

function getAdaptiveStep(scale) {
  const targetPx = 80;
  const steps = [1, 2, 5, 10];
  let base = Math.pow(10, Math.floor(Math.log10(1/scale*targetPx)));
  let bestStep = base, minDiff = Infinity;
  for (let s of steps) {
    let step = base * s;
    let px = step * scale;
    let diff = Math.abs(px - targetPx);
    if (diff < minDiff && px > 30) {
      minDiff = diff;
      bestStep = step;
    }
  }
  if (bestStep < 1) bestStep = Math.round(bestStep * 100) / 100;
  return bestStep;
}

function drawAxes() {
  ctx.save();
  let mainStep = getAdaptiveStep(scale);
  let subStep = mainStep / 5;
  if(showGrid) {
    ctx.strokeStyle = '#eee';
    ctx.lineWidth = 1;
    // 横向次网格
    let xStart = toMathX(0), xEnd = toMathX(width);
    let yStart = toMathY(height), yEnd = toMathY(0);
    for(let x = Math.ceil(xStart/subStep)*subStep; x <= xEnd; x += subStep) {
      if(Math.abs(x/mainStep-Math.round(x/mainStep))<1e-6) continue;
      ctx.beginPath();
      ctx.moveTo(toCanvasX(x), 0);
      ctx.lineTo(toCanvasX(x), height);
      ctx.stroke();
    }
    for(let y = Math.ceil(yStart/subStep)*subStep; y <= yEnd; y += subStep) {
      if(Math.abs(y/mainStep-Math.round(y/mainStep))<1e-6) continue;
      ctx.beginPath();
      ctx.moveTo(0, toCanvasY(y));
      ctx.lineTo(width, toCanvasY(y));
      ctx.stroke();
    }
    // 画主网格
    ctx.strokeStyle = '#ddd';
    ctx.lineWidth = 1.5;
    for(let x = Math.ceil(xStart/mainStep)*mainStep; x <= xEnd; x += mainStep) {
      ctx.beginPath();
      ctx.moveTo(toCanvasX(x), 0);
      ctx.lineTo(toCanvasX(x), height);
      ctx.stroke();
    }
    for(let y = Math.ceil(yStart/mainStep)*mainStep; y <= yEnd; y += mainStep) {
      ctx.beginPath();
      ctx.moveTo(0, toCanvasY(y));
      ctx.lineTo(width, toCanvasY(y));
      ctx.stroke();
    }
  }
  // 画坐标轴
  ctx.strokeStyle = '#444';
  ctx.lineWidth = 3;
  // 判断x轴/y轴是否在可见范围
  let xAxisInView = toCanvasY(0) >= 0 && toCanvasY(0) <= height;
  let yAxisInView = toCanvasX(0) >= 0 && toCanvasX(0) <= width;
  if(xAxisInView) ctx.beginPath(),ctx.moveTo(0,toCanvasY(0)),ctx.lineTo(width,toCanvasY(0)),ctx.stroke();
  if(yAxisInView) ctx.beginPath(),ctx.moveTo(toCanvasX(0),0),ctx.lineTo(toCanvasX(0),height),ctx.stroke();
  // 原点高亮
  if(xAxisInView && yAxisInView) {
    ctx.beginPath();
    ctx.arc(toCanvasX(0), toCanvasY(0), 7, 0, 2*Math.PI);
    ctx.fillStyle = '#f00';
    ctx.fill();
  }
  // 主刻度数字（只显示在可见区域）
  ctx.fillStyle = '#222';
  ctx.font = '13px Arial';
  let xMin = toMathX(0), xMax = toMathX(width);
  let yMin = toMathY(height), yMax = toMathY(0);
  // x轴主刻度
  let xStart = Math.ceil(xMin / mainStep) * mainStep;
  for(let x = xStart; x <= xMax; x += mainStep) {
    if(Math.abs(x)<1e-6) continue;
    let px = toCanvasX(x);
    if(px < 0 || px > width) continue;
    ctx.beginPath();
    ctx.moveTo(px, toCanvasY(0)-8);
    ctx.lineTo(px, toCanvasY(0)+8);
    ctx.strokeStyle = '#444';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.fillText(x.toFixed(mainStep<1?2:1), px - 10, toCanvasY(0) + 22);
  }
  // y轴主刻度
  let yStart = Math.ceil(yMin / mainStep) * mainStep;
  for(let y = yStart; y <= yMax; y += mainStep) {
    if(Math.abs(y)<1e-6) continue;
    let py = toCanvasY(y);
    if(py < 0 || py > height) continue;
    ctx.beginPath();
    ctx.moveTo(toCanvasX(0)-8, py);
    ctx.lineTo(toCanvasX(0)+8, py);
    ctx.strokeStyle = '#444';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.fillText(y.toFixed(mainStep<1?2:1), toCanvasX(0) + 10, py + 4);
  }
  // 边界主刻度数字（风格与主刻度一致）
  ctx.fillStyle = '#222';
  ctx.font = '13px Arial';
  // y轴不在可见范围，左边整条边标注y主刻度
  if(!yAxisInView) {
    for(let y = yStart; y <= yMax; y += mainStep) {
      if(Math.abs(y)<1e-6) continue;
      let py = toCanvasY(y);
      if(py < 0 || py > height) continue;
      ctx.fillText(y.toFixed(mainStep<1?2:1), 10, py + 4);
    }
  }
  // x轴不在可见范围，下边整条边标注x主刻度
  if(!xAxisInView) {
    for(let x = xStart; x <= xMax; x += mainStep) {
      if(Math.abs(x)<1e-6) continue;
      let px = toCanvasX(x);
      if(px < 0 || px > width) continue;
      ctx.fillText(x.toFixed(mainStep<1?2:1), px - 10, height - 8);
    }
  }
  ctx.restore();
}

function drawPoints() {
  ctx.save();
  points.forEach((pt, idx) => {
    // 计算参数化坐标
    let x, y;
    try {
      if (pt.xExpr && pt.yExpr && !pt.isDragged) {
        x = eval(substituteParameters(pt.xExpr));
        y = eval(substituteParameters(pt.yExpr));
      } else {
        x = pt.x;
        y = pt.y;
      }
    } catch {
      x = pt.x;
      y = pt.y;
    }
    
    ctx.beginPath();
    ctx.arc(toCanvasX(x), toCanvasY(y), 7, 0, 2*Math.PI);
    let isLineSelected = (mode==='line' && lineSelectPoints.includes(pt));
    // 拖动过的点显示为绿色
    let pointColor = pt.isDragged ? '#27ae60' : '#3498db';
    ctx.fillStyle = isLineSelected ? '#f90' : (selectedPointIdx===idx ? '#f90' : pointColor);
    ctx.fill();
    ctx.strokeStyle = '#333';
    ctx.lineWidth = (selectedPointIdx===idx) ? 3 : 1.5;
    ctx.stroke();
    ctx.fillStyle = '#222';
    ctx.font = 'bold 15px Arial';
    ctx.textAlign = (toCanvasX(x) < width/2) ? 'left' : 'right';
    ctx.fillText(String.fromCharCode(65+idx), toCanvasX(x)+(toCanvasX(x)<width/2?15:-15), toCanvasY(y)-10);
    
    // 更新点的实际坐标
    pt.x = x;
    pt.y = y;
  });
  ctx.restore();
}

function drawSegments() {
  ctx.save();
  ctx.strokeStyle = '#e74c3c';
  ctx.lineWidth = 2;
  segments.forEach((seg, idx) => {
    ctx.beginPath();
    ctx.moveTo(toCanvasX(seg.p1.x), toCanvasY(seg.p1.y));
    ctx.lineTo(toCanvasX(seg.p2.x), toCanvasY(seg.p2.y));
    ctx.stroke();
  });
  ctx.restore();
}

function drawCircles() {
  ctx.save();
  circles.forEach((c, idx) => {
    // 计算参数化属性
    let x, y, r;
    try {
      if (c.xExpr && c.yExpr && c.rExpr) {
        x = eval(substituteParameters(c.xExpr));
        y = eval(substituteParameters(c.yExpr));
        r = eval(substituteParameters(c.rExpr));
      } else {
        x = c.x;
        y = c.y;
        r = c.r;
      }
    } catch {
      x = c.x;
      y = c.y;
      r = c.r;
    }

    // 应用拖动偏移
    const offsetX = c.dragOffset ? c.dragOffset.x : 0;
    const offsetY = c.dragOffset ? c.dragOffset.y : 0;
    const cx = x + offsetX;
    const cy = y + offsetY;

    // 样式：选中橙色、拖动过绿色、默认绿色
    if(selectedCircleIdx === idx) {
      ctx.strokeStyle = '#f90';
      ctx.lineWidth = 4;
    } else {
      ctx.strokeStyle = c.isDragged ? '#27ae60' : '#27ae60';
      ctx.lineWidth = 2;
    }

    ctx.beginPath();
    ctx.arc(toCanvasX(cx), toCanvasY(cy), Math.abs(r)*scale, 0, 2*Math.PI);
    ctx.stroke();

    // 更新圆的实际属性（不覆盖表达式，仅用于其他功能）
    c.x = x;
    c.y = y;
    c.r = r;
  });
  ctx.restore();
}

function drawEllipses() {
  ctx.save();
  ellipses.forEach((e, idx) => {
    // 计算参数化属性
    let x, y, a, b;
    try {
      if (e.xExpr && e.yExpr && e.aExpr && e.bExpr) {
        x = eval(substituteParameters(e.xExpr));
        y = eval(substituteParameters(e.yExpr));
        a = eval(substituteParameters(e.aExpr));
        b = eval(substituteParameters(e.bExpr));
      } else {
        x = e.x;
        y = e.y;
        a = e.a;
        b = e.b;
      }
    } catch {
      x = e.x;
      y = e.y;
      a = e.a;
      b = e.b;
    }

    // 偏移
    const offsetX = e.dragOffset ? e.dragOffset.x : 0;
    const offsetY = e.dragOffset ? e.dragOffset.y : 0;
    
    // 高亮
    ctx.strokeStyle = (selectedEllipseIdx === idx) ? '#f90' : (e.isDragged ? '#27ae60' : '#2980b9');
    ctx.lineWidth = (selectedEllipseIdx === idx) ? 4 : 2;
    
    ctx.beginPath();
    for(let t=0;t<=2*Math.PI+0.01;t+=0.01) {
      let px = (x + offsetX) + a * Math.cos(t);
      let py = (y + offsetY) + b * Math.sin(t);
      let cx = toCanvasX(px), cy = toCanvasY(py);
      if(t===0) ctx.moveTo(cx, cy); else ctx.lineTo(cx, cy);
    }
    ctx.closePath();
    ctx.stroke();
  });
  ctx.restore();
}

function drawFunctions() {
  ctx.save();
  functions.forEach((fobj, idx) => {
    let expr = substituteParameters(fobj.expr);
    try {
      let xMin = toMathX(0), xMax = toMathX(width);
      let step = Math.max(0.01, (xMax-xMin)/1000);
      const offsetX = fobj.dragOffset ? fobj.dragOffset.x : 0;
      const offsetY = fobj.dragOffset ? fobj.dragOffset.y : 0;

      ctx.save();
      ctx.beginPath();
      let first = true;
      for(let x = xMin; x <= xMax; x += step) {
        let y;
        try { y = eval(expr); } catch { continue; }
        if(typeof y !== 'number' || !isFinite(y)) continue;
        let px = toCanvasX(x + offsetX);
        let py = toCanvasY(y + offsetY);
        if(first) { ctx.moveTo(px, py); first = false; }
        else ctx.lineTo(px, py);
      }

      // 高亮
      if(selectedFunctionIdx === idx) {
        ctx.strokeStyle = '#f90';
        ctx.lineWidth = 4;
      } else {
        ctx.strokeStyle = fobj.isDragged ? '#27ae60' : '#e67e22';
        ctx.lineWidth = 2;
      }
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;
      ctx.stroke();
      ctx.restore();
    } catch {}
  });
  ctx.restore();
}

function drawIntersectionPoints() {
  ctx.save();
  intersectionPoints.forEach((pt, idx) => {
    ctx.beginPath();
    ctx.arc(toCanvasX(pt.x), toCanvasY(pt.y), 6, 0, 2*Math.PI);
    ctx.fillStyle = '#e67e22';
    ctx.fill();
    ctx.strokeStyle = '#d35400';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.fillStyle = '#d35400';
    ctx.fillText('交点'+(idx+1), toCanvasX(pt.x)+10, toCanvasY(pt.y)-10);
  });
  ctx.restore();
}

function drawIntersectionLines() {
  ctx.save();
  intersectionLines.forEach((line, idx) => {
    let dx = line.p2.x - line.p1.x;
    let dy = line.p2.y - line.p1.y;
    if(dx === 0 && dy === 0) return;
    // 计算直线与画布四边的交点
    let points = [];
    // 上边 y=0
    {
      let y = toMathY(0);
      if(Math.abs(dy) > 1e-8) {
        let t = (y - line.p1.y) / dy;
        let x = line.p1.x + t * dx;
        let px = toCanvasX(x), py = toCanvasY(y);
        if(px >= 0 && px <= width) points.push({x, y});
      }
    }
    // 下边 y=height
    {
      let y = toMathY(height);
      if(Math.abs(dy) > 1e-8) {
        let t = (y - line.p1.y) / dy;
        let x = line.p1.x + t * dx;
        let px = toCanvasX(x), py = toCanvasY(y);
        if(px >= 0 && px <= width) points.push({x, y});
      }
    }
    // 左边 x=0
    {
      let x = toMathX(0);
      if(Math.abs(dx) > 1e-8) {
        let t = (x - line.p1.x) / dx;
        let y = line.p1.y + t * dy;
        let px = toCanvasX(x), py = toCanvasY(y);
        if(py >= 0 && py <= height) points.push({x, y});
      }
    }
    // 右边 x=width
    {
      let x = toMathX(width);
      if(Math.abs(dx) > 1e-8) {
        let t = (x - line.p1.x) / dx;
        let y = line.p1.y + t * dy;
        let px = toCanvasX(x), py = toCanvasY(y);
        if(py >= 0 && py <= height) points.push({x, y});
      }
    }
    // 取最远的两个交点
    if(points.length >= 2) {
      // 计算两两距离，取最远的两个
      let maxDist = 0, pA = points[0], pB = points[1];
      for(let i=0;i<points.length;i++){
        for(let j=i+1;j<points.length;j++){
          let d = Math.hypot(points[i].x-points[j].x, points[i].y-points[j].y);
          if(d > maxDist) { maxDist = d; pA = points[i]; pB = points[j]; }
        }
      }
      ctx.save();
      ctx.strokeStyle = '#6c3483';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(toCanvasX(pA.x), toCanvasY(pA.y));
      ctx.lineTo(toCanvasX(pB.x), toCanvasY(pB.y));
      ctx.stroke();
      // 标注直线方程在中点附近
      let mx = (pA.x + pB.x) / 2;
      let my = (pA.y + pB.y) / 2;
      let eq = getLineEquation(line.p1, line.p2);
      ctx.font = '13px Arial';
      ctx.fillStyle = '#6c3483';
      ctx.fillText(eq, toCanvasX(mx) + 10, toCanvasY(my) - 10);
      ctx.restore();
    }
  });
  ctx.restore();
}

function drawParabolas() {
  ctx.save();
  parabolas.forEach((pb, idx) => {
    // 拖动过的抛物线显示为绿色，选中的显示为橙色
    let strokeColor = '#8e44ad';
    if (pb.isDragged) strokeColor = '#27ae60';
    if (selectedParabolaIdx === idx) strokeColor = '#f90';
    
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = (selectedParabolaIdx === idx) ? 4 : 2;
    
    // 计算参数化属性
    let p;
    try {
      if (pb.pExpr) {
        p = eval(substituteParameters(pb.pExpr));
      } else {
        p = pb.p;
      }
    } catch {
      p = pb.p;
    }
    
    // 计算平移量
    const offsetX = pb.dragOffset ? pb.dragOffset.x : 0;
    const offsetY = pb.dragOffset ? pb.dragOffset.y : 0;
    
    // 根据视图范围动态调整绘制范围
    let xMin = toMathX(0), xMax = toMathX(width);
    let yMin = toMathY(height), yMax = toMathY(0);
    let maxRange = Math.max(Math.abs(xMax-xMin), Math.abs(yMax-yMin)) * 1.5;
    
    if(pb.type==='y2') {
      // y²=2px，平移后：(y-k)²=2p(x-h)
      ctx.beginPath();
      let first = true;
      
      // 扩大绘制范围，确保覆盖整个视图
      let viewRange = maxRange * 2;
      
      if(p > 0) {
        // p>0时，开口向右，从顶点开始绘制
        let startX = 0; // 抛物线的顶点在x=0
        let endX = viewRange;
        
        // 绘制上半支
        for(let x = startX; x <= endX; x += 0.02) {
          let y1 = Math.sqrt(2*p*x);
          if(isFinite(y1)) {
            let cx = toCanvasX(x + offsetX), cy1 = toCanvasY(y1 + offsetY);
            if(first) { 
              ctx.moveTo(cx, cy1); 
              first = false; 
            } else {
              ctx.lineTo(cx, cy1);
            }
          }
        }
        // 绘制下半支
        for(let x = endX; x >= startX; x -= 0.02) {
          let y = -Math.sqrt(2*p*x);
          if(isFinite(y)) {
            let cx = toCanvasX(x + offsetX), cy = toCanvasY(y + offsetY);
            ctx.lineTo(cx, cy);
          }
        }
      } else {
        // p<0时，开口向左，从顶点开始绘制
        let startX = 0; // 抛物线的顶点在x=0
        let endX = -viewRange;
        
        // 绘制上半支
        for(let x = startX; x >= endX; x -= 0.02) {
          let y1 = Math.sqrt(-2*p*x);
          if(isFinite(y1)) {
            let cx = toCanvasX(x + offsetX), cy1 = toCanvasY(y1 + offsetY);
            if(first) { 
              ctx.moveTo(cx, cy1); 
              first = false; 
            } else {
              ctx.lineTo(cx, cy1);
            }
          }
        }
        // 绘制下半支
        for(let x = endX; x <= startX; x += 0.02) {
          let y = -Math.sqrt(-2*p*x);
          if(isFinite(y)) {
            let cx = toCanvasX(x + offsetX), cy = toCanvasY(y + offsetY);
            ctx.lineTo(cx, cy);
          }
        }
      }
      ctx.stroke();
    } else {
      // x²=2py，平移后：(x-h)²=2p(y-k)
      ctx.beginPath();
      let first = true;
      
      // 扩大绘制范围，确保覆盖整个视图
      let viewRange = maxRange * 2;
      
      if(p > 0) {
        // p>0时，开口向上，从顶点开始绘制
        let startY = 0; // 抛物线的顶点在y=0
        let endY = viewRange;
        
        // 绘制右半支
        for(let y = startY; y <= endY; y += 0.02) {
          let x = Math.sqrt(2*p*y);
          if(isFinite(x)) {
            let cx1 = toCanvasX(x + offsetX), cy = toCanvasY(y + offsetY);
            if(first) { 
              ctx.moveTo(cx1, cy); 
              first = false; 
            } else {
              ctx.lineTo(cx1, cy);
            }
          }
        }
        // 绘制左半支
        for(let y = endY; y >= startY; y -= 0.02) {
          let x = -Math.sqrt(2*p*y);
          if(isFinite(x)) {
            let cx = toCanvasX(x + offsetX), cy = toCanvasY(y + offsetY);
            ctx.lineTo(cx, cy);
          }
        }
      } else {
        // p<0时，开口向下，从顶点开始绘制
        let startY = 0; // 抛物线的顶点在y=0
        let endY = -viewRange;
        
        // 绘制右半支
        for(let y = startY; y >= endY; y -= 0.02) {
          let x = Math.sqrt(-2*p*y);
          if(isFinite(x)) {
            let cx1 = toCanvasX(x + offsetX), cy = toCanvasY(y + offsetY);
            if(first) { 
              ctx.moveTo(cx1, cy); 
              first = false; 
            } else {
              ctx.lineTo(cx1, cy);
            }
          }
        }
        // 绘制左半支
        for(let y = endY; y <= startY; y += 0.02) {
          let x = -Math.sqrt(-2*p*y);
          if(isFinite(x)) {
            let cx = toCanvasX(x + offsetX), cy = toCanvasY(y + offsetY);
            ctx.lineTo(cx, cy);
          }
        }
      }
      ctx.stroke();
    }
  });
  ctx.restore();
}

function drawHyperbolas() {
  ctx.save();
  hyperbolas.forEach((hb, idx) => {
    // 计算参数化属性
    let x, y, a, b;
    try {
      if (hb.xExpr && hb.yExpr && hb.aExpr && hb.bExpr) {
        x = eval(substituteParameters(hb.xExpr));
        y = eval(substituteParameters(hb.yExpr));
        a = eval(substituteParameters(hb.aExpr));
        b = eval(substituteParameters(hb.bExpr));
      } else {
        x = hb.x;
        y = hb.y;
        a = hb.a;
        b = hb.b;
      }
    } catch {
      x = hb.x;
      y = hb.y;
      a = hb.a;
      b = hb.b;
    }

    const offsetX = hb.dragOffset ? hb.dragOffset.x : 0;
    const offsetY = hb.dragOffset ? hb.dragOffset.y : 0;

    ctx.strokeStyle = (selectedHyperbolaIdx === idx) ? '#f90' : (hb.isDragged ? '#27ae60' : '#e67e22');
    ctx.lineWidth = (selectedHyperbolaIdx === idx) ? 4 : 2;

    if(hb.dir==='x') {
      // x²/a² - y²/b² = 1
      // 右支
      ctx.beginPath();
      let first = true;
      for(let t=-4;t<=4;t+=0.02) {
        let px = (x + offsetX) + a*Math.cosh(t);
        let py = (y + offsetY) + b*Math.sinh(t);
        let cx = toCanvasX(px), cy = toCanvasY(py);
        if(first) { ctx.moveTo(cx, cy); first=false; } else ctx.lineTo(cx, cy);
      }
      ctx.stroke();
      
      // 左支
      ctx.beginPath();
      first = true;
      for(let t=-4;t<=4;t+=0.02) {
        let px = (x + offsetX) - a*Math.cosh(t);
        let py = (y + offsetY) + b*Math.sinh(t);
        let cx = toCanvasX(px), cy = toCanvasY(py);
        if(first) { ctx.moveTo(cx, cy); first=false; } else ctx.lineTo(cx, cy);
      }
      ctx.stroke();
    } else {
      // y²/a² - x²/b² = 1
      // 上支
      ctx.beginPath();
      let first = true;
      for(let t=-4;t<=4;t+=0.02) {
        let py = (y + offsetY) + a*Math.cosh(t);
        let px = (x + offsetX) + b*Math.sinh(t);
        let cx = toCanvasX(px), cy = toCanvasY(py);
        if(first) { ctx.moveTo(cx, cy); first=false; } else ctx.lineTo(cx, cy);
      }
      ctx.stroke();
      
      // 下支
      ctx.beginPath();
      first = true;
      for(let t=-4;t<=4;t+=0.02) {
        let py = (y + offsetY) - a*Math.cosh(t);
        let px = (x + offsetX) + b*Math.sinh(t);
        let cx = toCanvasX(px), cy = toCanvasY(py);
        if(first) { ctx.moveTo(cx, cy); first=false; } else ctx.lineTo(cx, cy);
      }
      ctx.stroke();
    }
  });
  ctx.restore();
}

function drawPolars() {
  ctx.save();
  polars.forEach(pobj => {
    let expr = substituteParameters(pobj.expr);
    ctx.beginPath();
    let first = true;
    const offsetX = pobj.dragOffset ? pobj.dragOffset.x : 0;
    const offsetY = pobj.dragOffset ? pobj.dragOffset.y : 0;

    for(let theta=0;theta<=4*Math.PI;theta+=0.01) { // 增加绘制范围
      let r;
      try { 
        // 替换theta和常见数学函数
        let evalExpr = expr
          .replace(/theta/g, theta)
          .replace(/th/g, theta)
          .replace(/sin/g, 'Math.sin')
          .replace(/cos/g, 'Math.cos')
          .replace(/tan/g, 'Math.tan')
          .replace(/\bpi\b/gi, 'Math.PI')
          .replace(/\bπ\b/g, 'Math.PI')
          .replace(/\be\b/g, 'Math.E')
          .replace(/\^/g, '**');
        r = eval(evalExpr); 
      } catch { continue; }
      if(typeof r !== 'number' || !isFinite(r)) continue;
      let x = r*Math.cos(theta) + offsetX, y = r*Math.sin(theta) + offsetY;
      let cx = toCanvasX(x), cy = toCanvasY(y);
      if(first) { ctx.moveTo(cx, cy); first=false; } else ctx.lineTo(cx, cy);
    }
    ctx.strokeStyle = pobj.isDragged ? '#27ae60' : '#16a085';
    ctx.lineWidth = 2;
    ctx.stroke();
  });
  ctx.restore();
}

// 计算直线方程字符串
function getLineEquation(p1, p2) {
  let A = +(p2.y - p1.y).toFixed(2);
  let B = +(p1.x - p2.x).toFixed(2);
  let C = +(p2.x*p1.y - p1.x*p2.y).toFixed(2);
  let eq = '';
  if(A!==0) eq += (A===1?'':(A===-1?'-':A))+'x';
  if(B!==0) eq += (B>0&&A!==0?'+':'')+(B===1?'':(B===-1?'-':B))+'y';
  if(C!==0) eq += (C>0?'+':'')+C;
  eq += '=0';
  return eq.replace('1x','x').replace('1y','y').replace('+-','-');
}

function redraw() {
  ctx.clearRect(0,0,width,height);
  drawAxes();
  drawSegments();
  drawCircles();
  drawEllipses();
  drawParabolas();
  drawHyperbolas();
  drawPolars();
  drawFunctions();
  drawIntersectionLines();
  drawIntersectionPoints();
  drawPoints();
  renderSidebar();
}

function toCanvasX(x) { return origin.x + (x - panOffset.x) * scale; }
function toCanvasY(y) { return origin.y - (y - panOffset.y) * scale; }
function toMathX(cx) { return Math.round(((cx - origin.x) / scale + panOffset.x) * 10) / 10; }
function toMathY(cy) { return Math.round(((origin.y - cy) / scale + panOffset.y) * 10) / 10; }

function evaluateExpression(expr) {
  try {
    const substituted = substituteParameters(expr);
    return eval(substituted);
  } catch {
    return parseFloat(expr) || 0;
  }
}

function addPointByInput() {
  const xInput = document.getElementById('input-x').value;
  const yInput = document.getElementById('input-y').value;
  
  detectAndAddParameters([xInput, yInput]);
  
  const x = evaluateExpression(xInput);
  const y = evaluateExpression(yInput);
  
  if(isNaN(x) || isNaN(y)) { 
    alert('请输入有效的坐标表达式！'); 
    return; 
  }
  
  saveState(); // 保存状态用于撤销
  
  points.push({
    x: Math.round(x*10)/10, 
    y: Math.round(y*10)/10,
    xExpr: xInput,
    yExpr: yInput
  });
  updateIntersections();
  redraw();
}

function addSegmentByInput() {
  const x1Input = document.getElementById('input-x1').value;
  const y1Input = document.getElementById('input-y1').value;
  const x2Input = document.getElementById('input-x2').value;
  const y2Input = document.getElementById('input-y2').value;
  
  detectAndAddParameters([x1Input, y1Input, x2Input, y2Input]);
  
  const x1 = evaluateExpression(x1Input);
  const y1 = evaluateExpression(y1Input);
  const x2 = evaluateExpression(x2Input);
  const y2 = evaluateExpression(y2Input);
  
  if([x1,y1,x2,y2].some(v=>isNaN(v))) { 
    alert('请输入有效的坐标表达式！'); 
    return; 
  }
  
  saveState(); // 保存状态用于撤销
  
  let p1 = findOrCreatePoint(Math.round(x1*10)/10, Math.round(y1*10)/10);
  let p2 = findOrCreatePoint(Math.round(x2*10)/10, Math.round(y2*10)/10);
  segments.push({p1, p2});
  updateIntersections();
  redraw();
}

function addCircleByInput() {
  const xInput = document.getElementById('input-x').value;
  const yInput = document.getElementById('input-y').value;
  const rInput = document.getElementById('input-r').value;
  
  detectAndAddParameters([xInput, yInput, rInput]);
  
  const x = evaluateExpression(xInput);
  const y = evaluateExpression(yInput);
  const r = evaluateExpression(rInput);
  
  if(isNaN(x) || isNaN(y) || isNaN(r) || r<=0) { 
    alert('请输入有效的圆心坐标和正数半径表达式！'); 
    return; 
  }
  
  saveState(); // 保存状态用于撤销
  
  let center = findOrCreatePoint(Math.round(x*10)/10, Math.round(y*10)/10);
  circles.push({
    x: Math.round(x*10)/10, 
    y: Math.round(y*10)/10, 
    r: Math.round(r*10)/10, 
    centerRef: center,
    xExpr: xInput,
    yExpr: yInput,
    rExpr: rInput
  });
  updateIntersections();
  redraw();
}

function addEllipseByInput() {
  const xInput = document.getElementById('input-x').value;
  const yInput = document.getElementById('input-y').value;
  const aInput = document.getElementById('input-a').value;
  const bInput = document.getElementById('input-b').value;
  
  detectAndAddParameters([xInput, yInput, aInput, bInput]);
  
  const x = evaluateExpression(xInput);
  const y = evaluateExpression(yInput);
  const a = evaluateExpression(aInput);
  const b = evaluateExpression(bInput);
  
  if(isNaN(x)||isNaN(y)||isNaN(a)||isNaN(b)||a<=0||b<=0) {
    alert('请输入有效的中心坐标和正数a、b表达式！'); 
    return;
  }
  
  saveState(); // 保存状态用于撤销
  
  ellipses.push({
    x: Math.round(x*10)/10, 
    y: Math.round(y*10)/10, 
    a: Math.round(a*10)/10, 
    b: Math.round(b*10)/10,
    xExpr: xInput,
    yExpr: yInput,
    aExpr: aInput,
    bExpr: bInput,
    raw: `椭圆 中心(${xInput},${yInput}) a=${aInput} b=${bInput}`
  });
  redraw();
}

function addParabolaByInput() {
  const type = document.getElementById('parabola-type').value;
  const pInput = document.getElementById('input-p').value;
  
  detectAndAddParameters([pInput]);
  
  const p = evaluateExpression(pInput);
  
  if(isNaN(p) || p === 0) {
    alert('请输入有效的参数p表达式（非零）！'); 
    return;
  }
  
  saveState(); // 保存状态用于撤销
  
  parabolas.push({
    type: type,
    p: Math.round(p*10)/10,
    pExpr: pInput,
    raw: `抛物线 ${type==='y2'?'y²=2px':'x²=2py'} p=${pInput}`
  });
  redraw();
}

function addHyperbolaByInput() {
  const xInput = document.getElementById('input-x').value;
  const yInput = document.getElementById('input-y').value;
  const aInput = document.getElementById('input-a').value;
  const bInput = document.getElementById('input-b').value;
  const dir = document.getElementById('hyperbola-type').value;
  
  detectAndAddParameters([xInput, yInput, aInput, bInput]);
  
  const x = evaluateExpression(xInput);
  const y = evaluateExpression(yInput);
  const a = evaluateExpression(aInput);
  const b = evaluateExpression(bInput);
  
  if(isNaN(x)||isNaN(y)||isNaN(a)||isNaN(b)||a<=0||b<=0) {
    alert('请输入有效的中心坐标和正数a、b表达式！'); 
    return;
  }
  
  saveState(); // 保存状态用于撤销
  
  hyperbolas.push({
    x: Math.round(x*10)/10,
    y: Math.round(y*10)/10,
    a: Math.round(a*10)/10,
    b: Math.round(b*10)/10,
    dir: dir,
    xExpr: xInput,
    yExpr: yInput,
    aExpr: aInput,
    bExpr: bInput,
    raw: `双曲线 中心(${xInput},${yInput}) a=${aInput} b=${bInput} ${dir==='x'?'x轴':'y轴'}方向`
  });
  redraw();
}

function addPolarByInput() {
  let polarStr = document.getElementById('input-polar').value;
  if(!polarStr) { alert('请输入极坐标方程！'); return; }
  
  detectAndAddParameters([polarStr]);
  
  // 预处理表达式
  let expr = polarStr.trim().toLowerCase();
  if(expr.startsWith('r=')) expr = expr.slice(2);
  
  // 替换常见的数学符号
  expr = expr.replace(/\^/g, '**')
             .replace(/\bpi\b/gi, 'Math.PI')
             .replace(/\bπ\b/g, 'Math.PI')
             .replace(/\be\b/g, 'Math.E');
  
  saveState(); // 保存状态用于撤销
  
  polars.push({
    expr: expr,
    raw: polarStr
  });
  redraw();
}

function addFunction() {
  let funcStr = document.getElementById('input-func').value;
  if(!funcStr) return;
  
  detectAndAddParameters([funcStr]);
  
  let expr = funcStr.trim().toLowerCase();
  if(expr.startsWith('y=')) expr = expr.slice(2);
  expr = expr.replace(/\^/g, '**')
             .replace(/sin/g, 'Math.sin')
             .replace(/cos/g, 'Math.cos')
             .replace(/tan/g, 'Math.tan')
             .replace(/exp/g, 'Math.exp')
             .replace(/log/g, 'Math.log10')
             .replace(/ln/g, 'Math.log')
             .replace(/abs/g, 'Math.abs')
             .replace(/\bpi\b/gi, 'Math.PI')
             .replace(/\bπ\b/g, 'Math.PI')
             .replace(/\be\b/g, 'Math.E');
  if(!Math.log10) Math.log10 = x => Math.log(x)/Math.LN10;
  
  saveState(); // 保存状态用于撤销
  
  functions.push({expr, raw: funcStr});
  updateIntersections();
  redraw();
}

function findOrCreatePoint(x, y) {
  let pt = points.find(p=>Math.abs(p.x-x)<1e-6 && Math.abs(p.y-y)<1e-6);
  if(!pt) { pt = {x, y}; points.push(pt); }
  return pt;
}

function toggleGrid() {
  showGrid = document.getElementById('toggle-grid').checked;
  redraw();
}

function confirmLine() {
  if(lineSelectPoints.length === 2 && lineSelectPoints[0] !== lineSelectPoints[1]) {
    saveState(); // 保存状态用于撤销
    intersectionLines.push({p1: lineSelectPoints[0], p2: lineSelectPoints[1]});
  }
  lineSelectPoints = [];
  lineSelectActive = false;
  switchMode('point');
  redraw();
}

function cancelLineSelect() {
  lineSelectPoints = [];
  lineSelectActive = true;
  renderInputArea();
  redraw();
}

// 触摸事件变量
let touchStartTime = 0;
let lastTouchPos = {x: 0, y: 0};
let isTouch = false;

// 获取事件位置（兼容鼠标和触摸）
function getEventPos(e) {
  if (e.touches && e.touches.length > 0) {
    return {clientX: e.touches[0].clientX, clientY: e.touches[0].clientY};
  }
  return {clientX: e.clientX, clientY: e.clientY};
}

canvas.onmousedown = function(e) {
  isTouch = e.type.includes('touch');
  if (isTouch) {
    touchStartTime = Date.now();
    e.preventDefault(); // 防止触摸滚动
  }
  
  const eventPos = getEventPos(e);
  const {x, y} = getMouseMathPos({clientX: eventPos.clientX, clientY: eventPos.clientY});
  
  // 点模式下点击画布即添加点
  if(mode==='point') {
    saveState(); // 保存状态用于撤销
    points.push({x: Math.round(x*10)/10, y: Math.round(y*10)/10});
    updateIntersections();
    redraw();
    return;
  }
  
  // 移动模式：只处理画布移动和缩放
  if(mode==='move') {
    if(e.shiftKey) {
      scalingCanvas = true;
    } else {
      draggingCanvas = true;
    }
    lastMouse = {x: eventPos.clientX, y: eventPos.clientY};
    canvas.style.cursor = scalingCanvas ? 'ns-resize' : 'grabbing';
    return;
  }
  
  // 拖动模式或其他模式：处理几何对象的选中和拖动
  let found = false;
  
  // 选中点
  for(let i=0;i<points.length;i++) {
    let pt = points[i];
    if(dist(pt, {x, y}) < 0.3) {
      selectedPointIdx = i;
      if(mode==='drag') {
        draggingPoint = pt;
        dragOffset.x = pt.x - x;
        dragOffset.y = pt.y - y;
      }
      found = true;
      redraw();
      
      // 作直线模式下选择点
      if(mode==='line' && lineSelectActive && lineSelectPoints.length < 2 && !lineSelectPoints.includes(pt)) {
        lineSelectPoints.push(pt);
        renderInputArea();
        redraw();
      }
      return;
    }
  }
  
  // 选中圆心
  if(mode==='drag') {
    for(let c of circles) {
      // 命中检测圆心
      const cx = (c.x || 0) + (c.dragOffset ? c.dragOffset.x : 0);
      const cy = (c.y || 0) + (c.dragOffset ? c.dragOffset.y : 0);
      if(dist({x, y}, {x: cx, y: cy}) < 0.5) {
        draggingPoint = c; // 使用c作为拖动对象（非点）
        dragOffset.x = cx - x;
        dragOffset.y = cy - y;
        draggingPoint._isCircleCenter = true; // 标记
        found = true;
        break;
      }
    }
  }
  
  // 选中曲线进行拖动（优先使用侧边栏选择）
  if(mode==='drag' && !found) {
    if (selectedCircleIdx !== null && circles[selectedCircleIdx]) {
      // 侧栏选择的圆，直接拖动
      const c = circles[selectedCircleIdx];
      draggingCurve = c;
      curveType = 'circle';
      dragOffset.x = x;
      dragOffset.y = y;
      dragOffset.initialOffsetX = c.dragOffset ? c.dragOffset.x : 0;
      dragOffset.initialOffsetY = c.dragOffset ? c.dragOffset.y : 0;
      if (!c.originalState) {
        c.originalState = { x: c.x, y: c.y, r: c.r };
      }
      found = true;
      redraw();
    } else if (selectedParabolaIdx !== null && parabolas[selectedParabolaIdx]) {
      // 如果侧边栏已选择抛物线，直接进入拖动
      draggingCurve = parabolas[selectedParabolaIdx];
      curveType = 'parabola';
      const pb = draggingCurve;
      dragOffset.x = x;
      dragOffset.y = y;
      dragOffset.initialOffsetX = pb.dragOffset ? pb.dragOffset.x : 0;
      dragOffset.initialOffsetY = pb.dragOffset ? pb.dragOffset.y : 0;
      if (!pb.originalState) {
        pb.originalState = { p: pb.p, pExpr: pb.pExpr, type: pb.type, raw: pb.raw };
      }
      found = true;
      redraw();
    } else if (selectedEllipseIdx !== null && ellipses[selectedEllipseIdx]) {
      draggingCurve = ellipses[selectedEllipseIdx];
      curveType = 'ellipse';
      const el = draggingCurve;
      dragOffset.x = x;
      dragOffset.y = y;
      dragOffset.initialOffsetX = el.dragOffset ? el.dragOffset.x : 0;
      dragOffset.initialOffsetY = el.dragOffset ? el.dragOffset.y : 0;
      if (!el.originalState) {
        el.originalState = { x: el.x, y: el.y, a: el.a, b: el.b, raw: el.raw };
      }
      found = true;
      redraw();
    } else if (selectedHyperbolaIdx !== null && hyperbolas[selectedHyperbolaIdx]) {
      draggingCurve = hyperbolas[selectedHyperbolaIdx];
      curveType = 'hyperbola';
      const hb = draggingCurve;
      dragOffset.x = x;
      dragOffset.y = y;
      dragOffset.initialOffsetX = hb.dragOffset ? hb.dragOffset.x : 0;
      dragOffset.initialOffsetY = hb.dragOffset ? hb.dragOffset.y : 0;
      if (!hb.originalState) {
        hb.originalState = { x: hb.x, y: hb.y, a: hb.a, b: hb.b, dir: hb.dir, raw: hb.raw };
      }
      found = true;
      redraw();
    } else if (selectedPolarIdx !== null && polars[selectedPolarIdx]) {
      draggingCurve = polars[selectedPolarIdx];
      curveType = 'polar';
      const po = draggingCurve;
      dragOffset.x = x;
      dragOffset.y = y;
      dragOffset.initialOffsetX = po.dragOffset ? po.dragOffset.x : 0;
      dragOffset.initialOffsetY = po.dragOffset ? po.dragOffset.y : 0;
      if (!po.originalState) {
        po.originalState = { expr: po.expr, raw: po.raw };
      }
      found = true;
      redraw();
    } else if (selectedFunctionIdx !== null && functions[selectedFunctionIdx]) {
      draggingCurve = functions[selectedFunctionIdx];
      curveType = 'function';
      const fu = draggingCurve;
      dragOffset.x = x;
      dragOffset.y = y;
      dragOffset.initialOffsetX = fu.dragOffset ? fu.dragOffset.x : 0;
      dragOffset.initialOffsetY = fu.dragOffset ? fu.dragOffset.y : 0;
      if (!fu.originalState) {
        fu.originalState = { expr: fu.expr, raw: fu.raw };
      }
      found = true;
      redraw();
    } else {
      // 未在侧边栏选择时，尝试基于命中检测选择（仅抛物线保持）
      for(let i = 0; i < parabolas.length; i++) {
        if(isPointNearParabola({x, y}, parabolas[i])) {
          draggingCurve = parabolas[i];
          curveType = 'parabola';
          selectedParabolaIdx = i; // 同步侧边栏选择状态
          dragOffset.x = x;
          dragOffset.y = y;
          dragOffset.initialOffsetX = parabolas[i].dragOffset ? parabolas[i].dragOffset.x : 0;
          dragOffset.initialOffsetY = parabolas[i].dragOffset ? parabolas[i].dragOffset.y : 0;
          if (!parabolas[i].originalState) {
            parabolas[i].originalState = { p: parabolas[i].p, pExpr: parabolas[i].pExpr, type: parabolas[i].type, raw: parabolas[i].raw };
          }
          found = true;
          redraw();
          break;
        }
      }
    }
  }
  
  // 作直线：交点也可选
  if(mode==='line' && lineSelectActive && lineSelectPoints.length < 2) {
    for(let i=0;i<intersectionPoints.length;i++) {
      let pt = intersectionPoints[i];
      if(dist(pt, {x, y}) < 0.3 && !lineSelectPoints.includes(pt)) {
        lineSelectPoints.push(pt);
        renderInputArea();
        redraw();
        return;
      }
    }
  }
};

canvas.onmousemove = function(e) {
  const eventPos = getEventPos(e);
  if(draggingPoint) {
    const {x, y} = getMouseMathPos({clientX: eventPos.clientX, clientY: eventPos.clientY});
    if (draggingPoint._isCircleCenter) {
      // 拖动圆：更新dragOffset
      const c = draggingPoint;
      const newCx = Math.round((x + dragOffset.x)*10)/10;
      const newCy = Math.round((y + dragOffset.y)*10)/10;
      const dx = newCx - (c.x || 0);
      const dy = newCy - (c.y || 0);
      c.dragOffset = {x: dx, y: dy};
      c.isDragged = true;
      generateTransformedEquationCircle(c);
      redraw();
      return;
    }
    draggingPoint.x = Math.round((x + dragOffset.x)*10)/10;
    draggingPoint.y = Math.round((y + dragOffset.y)*10)/10;
    
    // 标记点已被拖动
    draggingPoint.isDragged = true;
    
    // 如果是参数化的点，更新对应的参数值
    if(draggingPoint.xExpr && draggingPoint.yExpr) {
      updateParametersFromPoint(draggingPoint);
    }
    
    for(let c of circles) {
      if(c.centerRef === draggingPoint) {
        c.x = draggingPoint.x;
        c.y = draggingPoint.y;
      }
    }
    updateIntersections();
    redraw();
  } else if(draggingCurve) {
    const {x, y} = getMouseMathPos({clientX: eventPos.clientX, clientY: eventPos.clientY});
    
    if(curveType === 'parabola') {
      // 计算相对于初始点击位置的偏移量
      const dx = (x - dragOffset.x) + dragOffset.initialOffsetX;
      const dy = (y - dragOffset.y) + dragOffset.initialOffsetY;
      
      // 标记曲线已被拖动
      draggingCurve.isDragged = true;
      draggingCurve.dragOffset = {x: dx, y: dy};
      
      // 生成平移后的方程
      generateTransformedEquation(draggingCurve);
    } else if (curveType === 'ellipse' || curveType === 'hyperbola' || curveType === 'polar' || curveType === 'function' || curveType === 'circle') {
      const dx = (x - dragOffset.x) + dragOffset.initialOffsetX;
      const dy = (y - dragOffset.y) + dragOffset.initialOffsetY;
      draggingCurve.isDragged = true;
      draggingCurve.dragOffset = {x: dx, y: dy};
      if (curveType === 'ellipse') generateTransformedEquationEllipse(draggingCurve);
      if (curveType === 'hyperbola') generateTransformedEquationHyperbola(draggingCurve);
      if (curveType === 'polar') generateTransformedEquationPolar(draggingCurve);
      if (curveType === 'function') generateTransformedEquationFunction(draggingCurve);
      if (curveType === 'circle') generateTransformedEquationCircle(draggingCurve);
    }
    
    redraw();
  } else if(draggingCanvas) {
    let dx = (eventPos.clientX - lastMouse.x)/scale;
    let dy = (eventPos.clientY - lastMouse.y)/scale;
    panOffset.x -= dx;
    panOffset.y += dy;
    lastMouse = {x: eventPos.clientX, y: eventPos.clientY};
    redraw();
  } else if(scalingCanvas) {
    let dy = (eventPos.clientY - lastMouse.y);
    let factor = 1 - dy*0.01;
    let newScale = scale*factor;
    scale = newScale;
    lastMouse = {x: eventPos.clientX, y: eventPos.clientY};
    redraw();
  }
};

canvas.onmouseup = function() {
  draggingPoint = null;
  draggingCurve = null;
  curveType = null;
  
  if(draggingCanvas || scalingCanvas) {
    draggingCanvas = false;
    scalingCanvas = false;
    // 根据当前模式设置正确的光标
    if(mode==='move') {
      canvas.style.cursor = 'grab';
    } else if(mode==='drag') {
      canvas.style.cursor = 'pointer';
    } else if(mode==='point') {
      canvas.style.cursor = 'crosshair';
    } else if(mode==='line') {
      canvas.style.cursor = 'pointer';
    } else {
      canvas.style.cursor = 'default';
    }
  }
};

// 添加触摸事件支持
canvas.addEventListener('touchstart', canvas.onmousedown, {passive: false});
canvas.addEventListener('touchmove', canvas.onmousemove, {passive: false});
canvas.addEventListener('touchend', canvas.onmouseup, {passive: false});

// 新增：鼠标离开canvas时自动松手
canvas.addEventListener('mouseleave', function() {
  draggingCanvas = false;
  scalingCanvas = false;
  // 根据当前模式设置正确的光标
  if(mode==='move') {
    canvas.style.cursor = 'grab';
  } else if(mode==='drag') {
    canvas.style.cursor = 'pointer';
  } else if(mode==='point') {
    canvas.style.cursor = 'crosshair';
  } else if(mode==='line') {
    canvas.style.cursor = 'pointer';
  } else {
    canvas.style.cursor = 'default';
  }
});

// 鼠标滚轮事件监听 - 仅在canvas区域内缩放
canvas.addEventListener('wheel', function(e) {
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;
  
  // 检查鼠标是否在canvas内
  if (mouseX >= 0 && mouseX <= canvas.width && mouseY >= 0 && mouseY <= canvas.height) {
    e.preventDefault(); // 只在canvas内阻止默认滚动行为
    
    // 获取鼠标在数学坐标系中的位置
    const mathPos = getMouseMathPos(e);
    
    // 缩放因子
    const scaleFactor = e.deltaY > 0 ? 0.9 : 1.1;
    const oldScale = scale;
    scale *= scaleFactor;
    
    // 限制缩放范围，避免过度缩放
    scale = Math.max(5, Math.min(scale, 500));
    
    // 计算缩放后需要调整的平移量，使鼠标位置保持不变
    const scaleRatio = scale / oldScale;
    panOffset.x = mathPos.x - (mathPos.x - panOffset.x) / scaleRatio;
    panOffset.y = mathPos.y - (mathPos.y - panOffset.y) / scaleRatio;
    
    redraw();
  }
  // 如果鼠标不在canvas内，不阻止默认行为，允许页面滚动
}, { passive: false });

function getMouseMathPos(e) {
  const rect = canvas.getBoundingClientRect();
  const cx = e.clientX - rect.left;
  const cy = e.clientY - rect.top;
  return { x: ((cx-origin.x)/scale + panOffset.x), y: ((origin.y-cy)/scale + panOffset.y) };
}

function dist(p1, p2) { return Math.hypot(p1.x-p2.x, p1.y-p2.y); }

// 检测点是否靠近抛物线
function isPointNearParabola(point, parabola) {
  let p;
  try {
    if (parabola.pExpr) {
      p = eval(substituteParameters(parabola.pExpr));
    } else {
      p = parabola.p;
    }
  } catch {
    p = parabola.p;
  }
  
  const threshold = 1.0; // 增大距离阈值，便于选中
  const {x, y} = point;
  
  if(parabola.type === 'y2') {
    // y²=2px，计算点到抛物线的距离
    if(p > 0 && x >= -threshold) {
      const yExpected = x >= 0 ? Math.sqrt(2*p*Math.abs(x)) : 0;
      return Math.abs(Math.abs(y) - yExpected) < threshold;
    } else if(p < 0 && x <= threshold) {
      const yExpected = x <= 0 ? Math.sqrt(-2*p*Math.abs(x)) : 0;
      return Math.abs(Math.abs(y) - yExpected) < threshold;
    }
  } else {
    // x²=2py，计算点到抛物线的距离
    if(p > 0 && y >= -threshold) {
      const xExpected = y >= 0 ? Math.sqrt(2*p*Math.abs(y)) : 0;
      return Math.abs(Math.abs(x) - xExpected) < threshold;
    } else if(p < 0 && y <= threshold) {
      const xExpected = y <= 0 ? Math.sqrt(-2*p*Math.abs(y)) : 0;
      return Math.abs(Math.abs(x) - xExpected) < threshold;
    }
  }
  return false;
}

function resetAll() {
  if (confirm('确定要重置所有内容吗？此操作不可撤销。')) {
    saveState(); // 保存状态用于撤销
    points = [];
    segments = [];
    circles = [];
    ellipses = [];
    parabolas = [];
    hyperbolas = [];
    polars = [];
    functions = [];
    intersectionPoints = [];
    intersectionLines = [];
    panOffset = {x:0, y:0};
    scale = 40;
    selectedPointIdx = null;
    selectedSegmentIdx = null;
    selectedCircleIdx = null;
    selectedFunctionIdx = null;
    redraw();
  }
}

function updateIntersections() {
  intersectionPoints = [];
  for(let i=0;i<segments.length;i++){
    for(let j=i+1;j<segments.length;j++){
      let pt = segmentIntersection(segments[i], segments[j]);
      if(pt) intersectionPoints.push(pt);
    }
  }
  for(let seg of segments) {
    for(let c of circles) {
      let pts = segmentCircleIntersection(seg, c);
      pts.forEach(pt=>intersectionPoints.push(pt));
    }
  }
  for(let i=0;i<circles.length;i++){
    for(let j=i+1;j<circles.length;j++){
      let pts = circleCircleIntersection(circles[i], circles[j]);
      pts.forEach(pt=>intersectionPoints.push(pt));
    }
  }
}

function segmentIntersection(s1, s2) {
  let {x:x1, y:y1} = s1.p1, {x:x2, y:y2} = s1.p2;
  let {x:x3, y:y3} = s2.p1, {x:x4, y:y4} = s2.p2;
  let denom = (x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);
  if(denom===0) return null;
  let px = ((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4))/denom;
  let py = ((x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/denom;
  if(
    Math.min(x1,x2)-1e-6<=px && px<=Math.max(x1,x2)+1e-6 &&
    Math.min(y1,y2)-1e-6<=py && py<=Math.max(y1,y2)+1e-6 &&
    Math.min(x3,x4)-1e-6<=px && px<=Math.max(x3,x4)+1e-6 &&
    Math.min(y3,y4)-1e-6<=py && py<=Math.max(y3,y4)+1e-6
  ) return {x:Math.round(px*10)/10, y:Math.round(py*10)/10};
  return null;
}

function segmentCircleIntersection(seg, c) {
  let {x:x1, y:y1} = seg.p1, {x:x2, y:y2} = seg.p2;
  let {x:cx, y:cy, r} = c;
  let dx = x2-x1, dy = y2-y1;
  let fx = x1-cx, fy = y1-cy;
  let a = dx*dx+dy*dy;
  let b = 2*(fx*dx+fy*dy);
  let c0 = fx*fx+fy*fy-r*r;
  let D = b*b-4*a*c0;
  let pts = [];
  if(D<0) return pts;
  D = Math.sqrt(D);
  let t1 = (-b+D)/(2*a), t2 = (-b-D)/(2*a);
  [t1,t2].forEach(t=>{
    if(t>=0&&t<=1) {
      let px = x1+dx*t, py = y1+dy*t;
      pts.push({x:Math.round(px*10)/10, y:Math.round(py*10)/10});
    }
  });
  return pts;
}

function circleCircleIntersection(c1, c2) {
  let {x:x1, y:y1, r:r1} = c1, {x:x2, y:y2, r:r2} = c2;
  let dx = x2-x1, dy = y2-y1;
  let d = Math.hypot(dx, dy);
  if(d>r1+r2||d<Math.abs(r1-r2)||d===0) return [];
  let a = (r1*r1-r2*r2+d*d)/(2*d);
  let h = Math.sqrt(r1*r1-a*a);
  let xm = x1+a*dx/d, ym = y1+a*dy/d;
  let xs1 = xm+h*dy/d, ys1 = ym-h*dx/d;
  let xs2 = xm-h*dy/d, ys2 = ym+h*dx/d;
  return [ {x:Math.round(xs1*10)/10, y:Math.round(ys1*10)/10}, {x:Math.round(xs2*10)/10, y:Math.round(ys2*10)/10} ];
}

function renderSidebar() {
  // 点
  let pointList = document.getElementById('point-list');
  pointList.innerHTML = '';
  points.forEach((pt, idx) => {
    let li = document.createElement('li');
    let displayX = pt.xExpr || pt.x.toFixed(1);
    let displayY = pt.yExpr || pt.y.toFixed(1);
    
    // 显示拖动后的实际坐标
    let draggedInfo = '';
    if (pt.isDragged) {
      draggedInfo = ` → (${pt.x.toFixed(1)}, ${pt.y.toFixed(1)})`;
    }
    
    li.innerHTML = `
      <span class="item-text">${String.fromCharCode(65+idx)} (${displayX}, ${displayY})${draggedInfo}</span>
      <div style="display: inline-flex; gap: 2px;">
        ${pt.isDragged ? `<button class="delete-btn" onclick="restorePoint(${idx})" title="复原此点" style="background: #27ae60;">↶</button>` : ''}
        <button class="delete-btn" onclick="deletePoint(${idx})" title="删除点">×</button>
      </div>
    `;
    
    if(selectedPointIdx===idx) li.classList.add('selected');
    li.querySelector('.item-text').onclick = () => { selectedPointIdx = idx; redraw(); };
    pointList.appendChild(li);
  });
  
  // 线段
  let segList = document.getElementById('segment-list');
  segList.innerHTML = '';
  segments.forEach((seg, idx) => {
    let i1 = points.indexOf(seg.p1), i2 = points.indexOf(seg.p2);
    let li = document.createElement('li');
    li.innerHTML = `
      <span class="item-text">线段 ${String.fromCharCode(65+i1)}${String.fromCharCode(65+i2)}</span>
      <button class="delete-btn" onclick="deleteSegment(${idx})" title="删除线段">×</button>
    `;
    segList.appendChild(li);
  });
  
  // 直线
  let lineList = document.getElementById('line-list');
  lineList.innerHTML = '';
  intersectionLines.forEach((line, idx) => {
    let eq = getLineEquation(line.p1, line.p2);
    let i1 = points.indexOf(line.p1), i2 = points.indexOf(line.p2);
    let label = '';
    if(i1>=0 && i2>=0) label = `直线 ${String.fromCharCode(65+i1)}${String.fromCharCode(65+i2)}`;
    else label = `直线 (${line.p1.x.toFixed(1)},${line.p1.y.toFixed(1)})-(${line.p2.x.toFixed(1)},${line.p2.y.toFixed(1)})`;
    
    let li = document.createElement('li');
    li.innerHTML = `
      <span class="item-text">${label} ${eq}</span>
      <button class="delete-btn" onclick="deleteLine(${idx})" title="删除直线">×</button>
    `;
    lineList.appendChild(li);
  });
  
  // 圆
  let circleList = document.getElementById('circle-list');
  circleList.innerHTML = '';
  circles.forEach((c, idx) => {
    let rDisplay = c.rExpr || c.r.toFixed(1);
    let li = document.createElement('li');
    // 圆编号 O₁、O₂、O₃ ...
    let circleNum = idx + 1;
    let display = `圆 O<sub>${circleNum}</sub> (r=${rDisplay})`;
    if (c.isDragged && c.transformedEquation) {
      display += `<br><span style="color: #27ae60; font-size: 12px;">→ ${c.transformedEquation}</span>`;
    }
    li.innerHTML = `
      <span class="item-text">${display}</span>
      <button class="delete-btn" onclick="deleteCircle(${idx})" title="删除圆">×</button>
    `;
    if(selectedCircleIdx === idx) li.classList.add('selected');
    li.querySelector('.item-text').onclick = () => {
      if(selectedCircleIdx === idx) {
        selectedCircleIdx = null;
      } else {
        selectedCircleIdx = idx;
        switchMode('drag');
      }
      redraw();
    };
    circleList.appendChild(li);
  });
  
  // 函数/方程
  let funcList = document.getElementById('function-list');
  funcList.innerHTML = '';
  
  // 函数/方程编号 f₁(x)、f₂(x)...
  functions.forEach((f, idx) => {
    let li = document.createElement('li');
    let funcNum = idx + 1;
    let display = '';
    if (f.raw && /^y\s*=/.test(f.raw.trim())) {
      display = `f<sub>${funcNum}</sub>(x) = ${f.raw.trim().replace(/^y\s*=/, '')}`;
    } else if (f.raw && /^x\s*=/.test(f.raw.trim())) {
      display = `f<sub>${funcNum}</sub>(y) = ${f.raw.trim().replace(/^x\s*=/, '')}`;
    } else if (f.raw) {
      display = `f<sub>${funcNum}</sub>: ${f.raw}`;
    } else {
      display = `f<sub>${funcNum}</sub>(x)`;
    }
    if (f.isDragged && f.transformedEquation) {
      display += `<br><span style="color: #27ae60; font-size: 12px;">→ ${f.transformedEquation}</span>`;
    }
    li.innerHTML = `
      <span class="item-text">${display}</span>
      <button class="delete-btn" onclick="deleteFunction(${idx})" title="删除函数">×</button>
    `;
    if(selectedFunctionIdx === idx) li.classList.add('selected');
    li.querySelector('.item-text').onclick = () => {
      if (selectedFunctionIdx === idx) {
        selectedFunctionIdx = null;
      } else {
        selectedFunctionIdx = idx;
        switchMode('drag');
      }
      redraw();
    };
    funcList.appendChild(li);
  });
  
  // 椭圆
  ellipses.forEach((e, idx) => {
    let li = document.createElement('li');
    let display = e.raw || '椭圆';
    if (e.isDragged && e.transformedEquation) {
      display += `<br><span style="color: #27ae60; font-size: 12px;">→ ${e.transformedEquation}</span>`;
    }
    li.innerHTML = `
      <span class="item-text">${display}</span>
      <button class="delete-btn" onclick="deleteEllipse(${idx})" title="删除椭圆">×</button>
    `;
    if (selectedEllipseIdx === idx) li.classList.add('selected');
    li.querySelector('.item-text').onclick = () => {
      if (selectedEllipseIdx === idx) {
        selectedEllipseIdx = null;
      } else {
        selectedEllipseIdx = idx;
        switchMode('drag');
      }
      redraw();
    };
    funcList.appendChild(li);
  });
  
  // 抛物线
  parabolas.forEach((p, idx) => {
    let li = document.createElement('li');
    
    // 构建显示文本
    let displayText = p.raw || '抛物线';
    if (p.isDragged && p.transformedEquation) {
      displayText += `<br><span style="color: #27ae60; font-size: 12px;">→ ${p.transformedEquation}</span>`;
    }
    
    li.innerHTML = `
      <span class="item-text">${displayText}</span>
      <div style="display: inline-flex; gap: 2px;">
        ${p.isDragged ? `<button class="delete-btn" onclick="restoreParabola(${idx})" title="复原此抛物线" style="background: #27ae60;">↶</button>` : ''}
        <button class="delete-btn" onclick="deleteParabola(${idx})" title="删除抛物线">×</button>
      </div>
    `;
    // 侧边栏高亮与点击选择/取消
    if (selectedParabolaIdx === idx) li.classList.add('selected');
    li.querySelector('.item-text').onclick = () => {
      if (selectedParabolaIdx === idx) {
        selectedParabolaIdx = null;
      } else {
        selectedParabolaIdx = idx;
        // 进入拖动模式，方便直接拖动
        switchMode('drag');
      }
      redraw();
    };
    funcList.appendChild(li);
  });
  
  // 双曲线
  hyperbolas.forEach((h, idx) => {
    let li = document.createElement('li');
    let display = h.raw || '双曲线';
    if (h.isDragged && h.transformedEquation) {
      display += `<br><span style="color: #27ae60; font-size: 12px;">→ ${h.transformedEquation}</span>`;
    }
    li.innerHTML = `
      <span class="item-text">${display}</span>
      <button class="delete-btn" onclick="deleteHyperbola(${idx})" title="删除双曲线">×</button>
    `;
    if (selectedHyperbolaIdx === idx) li.classList.add('selected');
    li.querySelector('.item-text').onclick = () => {
      if (selectedHyperbolaIdx === idx) {
        selectedHyperbolaIdx = null;
      } else {
        selectedHyperbolaIdx = idx;
        switchMode('drag');
      }
      redraw();
    };
    funcList.appendChild(li);
  });
  
  // 极坐标
  polars.forEach((p, idx) => {
    let li = document.createElement('li');
    let display = p.raw || '极坐标';
    if (p.isDragged && p.transformedEquation) {
      display += `<br><span style="color: #27ae60; font-size: 12px;">→ ${p.transformedEquation}</span>`;
    }
    li.innerHTML = `
      <span class="item-text">${display}</span>
      <button class="delete-btn" onclick="deletePolar(${idx})" title="删除极坐标曲线">×</button>
    `;
    if (selectedPolarIdx === idx) li.classList.add('selected');
    li.querySelector('.item-text').onclick = () => {
      if (selectedPolarIdx === idx) {
        selectedPolarIdx = null;
      } else {
        selectedPolarIdx = idx;
        switchMode('drag');
      }
      redraw();
    };
    funcList.appendChild(li);
  });
}

// 初始化
switchMode('move'); // 默认选中移动模式
renderParameterControls();
updateIntersections();
redraw();

// 键盘事件监听
document.addEventListener('keydown', function(e) {
  // Ctrl+Z 撤销
  if (e.ctrlKey && e.key === 'z') {
    e.preventDefault();
    undo();
  }
  
  // 方向键控制选中的曲线平移
  if (mode === 'drag' && (selectedParabolaIdx !== null || selectedPointIdx !== null)) {
    const step = 0.1; // 每次移动的步长
    let moved = false;
    
    switch(e.key) {
      case 'ArrowUp':
        e.preventDefault();
        if (selectedParabolaIdx !== null) {
          moveParabola(selectedParabolaIdx, 0, step);
          moved = true;
        } else if (selectedPointIdx !== null) {
          movePoint(selectedPointIdx, 0, step);
          moved = true;
        }
        break;
      case 'ArrowDown':
        e.preventDefault();
        if (selectedParabolaIdx !== null) {
          moveParabola(selectedParabolaIdx, 0, -step);
          moved = true;
        } else if (selectedPointIdx !== null) {
          movePoint(selectedPointIdx, 0, -step);
          moved = true;
        }
        break;
      case 'ArrowLeft':
        e.preventDefault();
        if (selectedParabolaIdx !== null) {
          moveParabola(selectedParabolaIdx, -step, 0);
          moved = true;
        } else if (selectedPointIdx !== null) {
          movePoint(selectedPointIdx, -step, 0);
          moved = true;
        }
        break;
      case 'ArrowRight':
        e.preventDefault();
        if (selectedParabolaIdx !== null) {
          moveParabola(selectedParabolaIdx, step, 0);
          moved = true;
        } else if (selectedPointIdx !== null) {
          movePoint(selectedPointIdx, step, 0);
          moved = true;
        }
        break;
    }
    
    if (moved) {
      redraw();
    }
  }
});

// 全屏按钮JS
const fullscreenBtn = document.getElementById('fullscreen-btn');
fullscreenBtn.onclick = function() {
  const el = document.documentElement;
  if (!document.fullscreenElement) {
    el.requestFullscreen();
  } else {
    document.exitFullscreen();
  }
};

// 导出图片按钮
const exportBtn = document.getElementById('export-image-btn');
exportBtn.onclick = function exportCanvasAsImage() {
  const canvasEl = document.getElementById('canvas');
  if (!canvasEl) return;
  const bgMode = (document.getElementById('export-bg-select')||{}).value || 'white';

  // 合成导出画布
  const w = canvasEl.width;
  const h = canvasEl.height;
  const off = document.createElement('canvas');
  off.width = w; off.height = h;
  const octx = off.getContext('2d');
  if (bgMode === 'white') {
    octx.save();
    octx.fillStyle = '#ffffff';
    octx.fillRect(0,0,w,h);
    octx.restore();
  }
  octx.drawImage(canvasEl, 0, 0);

  const filename = `graph-${new Date().toISOString().replace(/[:.]/g,'-')}.png`;
  if (off.toBlob) {
    off.toBlob(function(blob){
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      setTimeout(()=>URL.revokeObjectURL(url), 1000);
    });
  } else {
    // 兼容旧浏览器
    const dataURL = off.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = dataURL;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  }
};

document.addEventListener('fullscreenchange', function() {
  if(document.fullscreenElement) {
    fullscreenBtn.innerText = '⛶';
    fullscreenBtn.title = '退出全屏';
  } else {
    fullscreenBtn.innerText = '⛶';
    fullscreenBtn.title = '全屏';
  }
});

// 单个参数重置为0
function resetParameter(name) {
  if (parameters.hasOwnProperty(name)) {
    parameters[name] = 0;
    renderParameterControls();
    redraw();
  }
}

// 视角复位按钮逻辑
document.getElementById('reset-view-btn').onclick = function() {
  panOffset = {x:0, y:0};
  scale = 40;
  redraw();
};

// 移动端菜单控制
function toggleMobileMenu() {
  const sidebar = document.querySelector('.sidebar');
  const overlay = document.querySelector('.mobile-overlay');
  
  sidebar.classList.toggle('show');
  overlay.classList.toggle('show');
}

function hideMobileMenu() {
  const sidebar = document.querySelector('.sidebar');
  const overlay = document.querySelector('.mobile-overlay');
  
  sidebar.classList.remove('show');
  overlay.classList.remove('show');
}

// 阻止触摸滚动穿透
document.addEventListener('touchmove', function(e) {
  const sidebar = document.querySelector('.sidebar');
  if (sidebar.classList.contains('show') && !sidebar.contains(e.target)) {
    e.preventDefault();
  }
}, {passive: false});
</script>
</body>
</html>
