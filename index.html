<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>å«å‚å‡½æ•°è§£æå‡ ä½•æ•™å­¦å·¥å…·</title>
  <style>
    body { font-family: Arial, sans-serif; background: #f8f8f8; margin:0; }
    .container { display: flex; height: 100vh; }
    .sidebar {
      width: 320px;
      background: #f4f6fa;
      border-right: 1px solid #ddd;
      padding: 18px 10px 10px 18px;
      overflow-y: auto;
    }
    .sidebar h3 { margin: 10px 0 6px 0; font-size: 18px; color: #3498db; }
    .sidebar ul { list-style: none; padding: 0; margin: 0 0 10px 0; }
    .sidebar li { margin-bottom: 7px; cursor: pointer; padding: 3px 6px; border-radius: 4px; }
    .sidebar li.selected { background: #d0e8ff; color: #217dbb; font-weight: bold; }
    .main { flex: 1; display: flex; flex-direction: column; }
    .toolbar {
      text-align: left;
      padding: 12px 0 8px 30px;
      background: #fff;
      border-bottom: 1px solid #eee;
    }
    .toolbar button {
      font-size: 16px;
      margin: 0 5px 0 0;
      padding: 6px 16px;
    }
    .input-area {
      text-align: left;
      margin: 10px 0 0 30px;
    }
    .input-area input, .input-area button {
      font-size: 16px;
      margin: 0 5px 0 0;
      padding: 6px 10px;
    }
    .active-btn {
      background: #3498db;
      color: #fff;
      border: none;
    }
    #canvas {
      background: #fff;
      border: 1px solid #ccc;
      margin: 18px auto 0 auto;
      box-shadow: 0 2px 8px #ddd;
      display: block;
      cursor: grab;
    }
    .intersection-point { fill: #e67e22; stroke: #d35400; stroke-width: 2px; }
    /* ä¸‹æ‹‰èœå•æ ·å¼ */
    .dropdown {
      position: relative;
      display: inline-block;
    }
    .dropdown-toggle {
      background-color: #f4f6fa;
      color: #333;
      border: 1px solid #ccc;
      padding: 6px 16px;
      font-size: 16px;
      cursor: pointer;
      border-radius: 4px;
    }
    .dropdown-toggle:hover {
      background-color: #e0e0e0;
    }
    .dropdown-menu {
      position: absolute;
      background-color: #fff;
      min-width: 160px;
      box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
      z-index: 1000;
      border-radius: 4px;
      border: 1px solid #ccc;
    }
    .dropdown-item {
      padding: 12px 16px;
      cursor: pointer;
      color: #333;
      font-size: 14px;
    }
    .dropdown-item:hover {
      background-color: #f0f0f0;
    }
    /* å‚æ•°æ§åˆ¶æ ·å¼ */
    .parameter-control {
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 6px;
      padding: 12px;
      margin: 8px 0;
    }
    .parameter-item {
      margin: 8px 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .parameter-item label {
      min-width: 30px;
      font-weight: bold;
      color: #2c3e50;
    }
    .parameter-item input[type="range"] {
      flex: 1;
      height: 6px;
      background: #ddd;
      outline: none;
      border-radius: 3px;
    }
    .parameter-item input[type="number"] {
      width: 60px;
      padding: 4px;
      border: 1px solid #ccc;
      border-radius: 3px;
    }
    .parameter-detected {
      background: #e8f5e8;
      color: #27ae60;
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 4px;
      margin: 4px 0;
    }
    /* åˆ é™¤æŒ‰é’®æ ·å¼ */
    .delete-btn {
      background: #e74c3c;
      color: white;
      border: none;
      border-radius: 3px;
      padding: 2px 6px;
      font-size: 12px;
      cursor: pointer;
      margin-left: 8px;
      opacity: 0.7;
      transition: opacity 0.2s;
    }
    .delete-btn:hover {
      opacity: 1;
    }
    .sidebar li {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .sidebar li .item-text {
      flex: 1;
    }
  </style>
</head>
<body>
<div class="container">
  <div class="sidebar">
    <!-- å‚æ•°æ§åˆ¶åŒºåŸŸ -->
    <div class="parameter-control">
      <h3 style="margin: 0 0 8px 0; color: #e74c3c;">å‚æ•°æ§åˆ¶</h3>
      <div id="parameter-list"></div>
      <div style="margin-top: 10px;">
        <button onclick="addCustomParameter()" style="font-size: 14px; padding: 4px 8px;">æ·»åŠ å‚æ•°</button>
        <button onclick="resetParameters()" style="font-size: 14px; padding: 4px 8px;">é‡ç½®å‚æ•°</button>
        <button onclick="restoreOriginalPositions()" style="font-size: 14px; padding: 4px 8px; background: #27ae60; color: white;">å¤åŸæ‰€æœ‰ç‚¹</button>
      </div>
    </div>
    
    <!-- æ•°å­¦å¸¸æ•°è¯´æ˜ -->
    <div style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 6px; padding: 12px; margin: 8px 0; font-size: 13px; color: #856404;">
      <div style="font-weight: bold; margin-bottom: 6px;">ğŸ“š æ•°å­¦å¸¸æ•°è¯´æ˜</div>
      <div style="margin-bottom: 4px;">â€¢ <strong>e</strong> = 2.71828... (è‡ªç„¶å¯¹æ•°çš„åº•æ•°)</div>
      <div style="margin-bottom: 4px;">â€¢ <strong>Ï€</strong> æˆ– <strong>pi</strong> = 3.14159... (åœ†å‘¨ç‡)</div>
      <div style="color: #27ae60; font-weight: bold;">âœ… è¿™äº›æ•°å­¦å¸¸æ•°ä¼šè¢«è‡ªåŠ¨è¯†åˆ«ï¼Œä¸ä¼šè¯¯è®¤ä¸ºå‚æ•°</div>
      <div style="color: #e74c3c; font-weight: bold;">âš ï¸ æ³¨æ„ï¼šsin, cos, tan, exp, log ç­‰å‡½æ•°åä¹Ÿä¸ä¼šè¢«è¯†åˆ«ä¸ºå‚æ•°</div>
    </div>
    
    <h3>ç‚¹</h3>
    <ul id="point-list"></ul>
    <h3>çº¿æ®µ/ç›´çº¿</h3>
    <ul id="segment-list"></ul>
    <h3>ç›´çº¿</h3>
    <ul id="line-list"></ul>
    <h3>åœ†</h3>
    <ul id="circle-list"></ul>
    <h3>å‡½æ•°/æ–¹ç¨‹</h3>
    <ul id="function-list"></ul>
  </div>
  <div class="main">
    <div class="toolbar">
      <button id="btn-move" onclick="switchMode('move')">ç§»åŠ¨ç”»å¸ƒ</button>
      <button id="btn-drag" onclick="switchMode('drag')">æ‹–åŠ¨å¯¹è±¡</button>
      <button id="btn-point" onclick="switchMode('point')">ç‚¹</button>
      <button id="btn-segment" onclick="switchMode('segment')">çº¿æ®µ</button>
      <div class="dropdown" style="display:inline-block;position:relative;">
        <button id="btn-function" class="dropdown-toggle active-btn" onclick="toggleFunctionMenu()">å«å‚å‡½æ•°â–¼</button>
        <div class="dropdown-menu" id="function-menu" style="display:none;position:absolute;left:0;top:36px;background:#fff;border:1px solid #ccc;border-radius:6px;box-shadow:0 2px 8px #eee;z-index:10;min-width:120px;">
          <div class="dropdown-item" data-type="circle">åœ†</div>
          <div class="dropdown-item" data-type="ellipse">æ¤­åœ†</div>
          <div class="dropdown-item" data-type="parabola">æŠ›ç‰©çº¿</div>
          <div class="dropdown-item" data-type="hyperbola">åŒæ›²çº¿</div>
          <div class="dropdown-item" data-type="equation">ç›´æ¥è¾“å…¥æ–¹ç¨‹</div>
          <div class="dropdown-item" data-type="polar">æåæ ‡</div>
        </div>
      </div>
      <button id="btn-line" onclick="switchMode('line')">ä½œç›´çº¿</button>
      <button onclick="resetAll()">é‡ç½®</button>
    </div>
    <div class="input-area" id="input-area"></div>
    <div id="function-type-label" style="margin-left:30px;margin-top:8px;font-size:17px;color:#217dbb;"></div>
    <div id="parameter-hint" style="margin-left:30px;margin-top:4px;font-size:14px;color:#7f8c8d;"></div>
    <div style="position:relative;flex:1;">
      <canvas id="canvas" width="900" height="600"></canvas>
      <button id="reset-view-btn" title="è§†è§’å¤ä½" style="position:absolute;top:12px;right:18px;z-index:1001;background:#fff;border:1px solid #ccc;border-radius:6px;padding:4px 12px;font-size:15px;cursor:pointer;">è§†è§’å¤ä½</button>
      <div style="position:absolute;right:18px;bottom:12px;font-size:15px;background:rgba(255,255,255,0.8);padding:4px 10px;border-radius:6px;">
        <label><input type="checkbox" id="toggle-grid" checked onchange="toggleGrid()"> æ˜¾ç¤ºç½‘æ ¼</label>
      </div>
    </div>
    <button id="fullscreen-btn" title="å…¨å±" style="position:fixed;top:16px;right:24px;z-index:1000;background:#fff;border:1px solid #ccc;border-radius:6px;padding:6px 14px;font-size:18px;cursor:pointer;transition:box-shadow 0.2s;">â›¶</button>
    <style>
    #fullscreen-btn:hover { box-shadow:0 2px 8px #aaa; }
    </style>
  </div>
</div>
<script>
// æ•°æ®ç»“æ„
let points = [];
let segments = [];
let circles = [];
let functions = [];
let intersectionPoints = [];
let intersectionLines = [];
let draggingPoint = null;
let dragOffset = {x:0, y:0};
let mode = 'point';
let tempSegment = [];
let tempCircle = [];
let tempLine = [];
let clickAddPointMode = false;
let selectedPointIdx = null;
let selectedSegmentIdx = null;
let selectedCircleIdx = null;
let selectedFunctionIdx = null;
let selectedEllipseIdx = null;
let selectedParabolaIdx = null;
let selectedHyperbolaIdx = null;
let selectedPolarIdx = null;
let draggingCurve = null;
let curveType = null;
let lineSelectPoints = [];
let lineSelectActive = false;
let ellipses = [];
let parabolas = [];
let hyperbolas = [];
let polars = [];

// å‚æ•°ç³»ç»Ÿ
let parameters = {}; // å­˜å‚¨æ‰€æœ‰å‚æ•° {name: value}
let parameterRanges = {}; // å­˜å‚¨å‚æ•°èŒƒå›´ {name: {min, max, step}}

// æ’¤é”€ç³»ç»Ÿ
let operationHistory = []; // æ“ä½œå†å²
const maxHistorySize = 50; // æœ€å¤§å†å²è®°å½•æ•°

// åæ ‡ç³»å¹³ç§»/ç¼©æ”¾
let draggingCanvas = false;
let scalingCanvas = false;
let panOffset = {x: 0, y: 0}; // è§†å›¾å¹³ç§»é‡ï¼Œå•ä½ï¼šæ•°å­¦åæ ‡
let lastMouse = {x: 0, y: 0};
let scale = 40; // åˆå§‹ç¼©æ”¾æ¯”ä¾‹
// æ— é™ç¼©æ”¾ï¼Œä¸å†é™åˆ¶ minScale/maxScale
// const minScale = 10, maxScale = 200;
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const width = canvas.width;
const height = canvas.height;
let origin = { x: width/2, y: height/2 };
let showGrid = true;

// å…¨å±€å˜é‡ï¼šæ˜¯å¦è·³è¿‡åˆ é™¤ç¡®è®¤
let skipDeleteConfirm = false;

// å‚æ•°ç®¡ç†å‡½æ•°
function extractParameters(text) {
  if (!text) return [];
  
  // é¦–å…ˆæ›¿æ¢æ‰æ•°å­¦å¸¸æ•°ï¼Œé¿å…å®ƒä»¬è¢«è¯¯è¯†åˆ«ä¸ºå‚æ•°
  let processedText = text.toString()
    .replace(/\bpi\b/gi, '3.14159')  // æ›¿æ¢piä¸ºæ•°å­—
    .replace(/\bÏ€\b/g, '3.14159')    // æ›¿æ¢Ï€ä¸ºæ•°å­—
    .replace(/\be\b/g, '2.71828');   // æ›¿æ¢eä¸ºæ•°å­—
  
  // æ’é™¤å¸¸ç”¨å˜é‡å’Œå‡½æ•°å
  const exclude = ['x', 'y', 'r', 'theta', 'th', 'sin', 'cos', 'tan', 'exp', 'log', 'ln', 'abs'];
  const params = [];
  
  // åŒ¹é…æ‰€æœ‰å­—æ¯
  const matches = processedText.match(/[a-zA-Z]/g) || [];
  matches.forEach(ch => {
    const lower = ch.toLowerCase();
    if (!exclude.includes(lower) && !params.includes(ch)) {
      params.push(ch);
    }
  });
  return params;
}

// æµ‹è¯•å‡½æ•° - å¯ä»¥åœ¨æµè§ˆå™¨æ§åˆ¶å°è°ƒç”¨
function testParameterExtraction() {
  console.log('æµ‹è¯•å‚æ•°æå–ï¼š');
  console.log('pi -> ', extractParameters('pi'));
  console.log('pi*r -> ', extractParameters('pi*r'));
  console.log('2*pi*r -> ', extractParameters('2*pi*r'));
  console.log('a*pi + b -> ', extractParameters('a*pi + b'));
  console.log('sin(pi/4) -> ', extractParameters('sin(pi/4)'));
}

function testParameterSubstitution() {
  console.log('æµ‹è¯•å‚æ•°æ›¿æ¢ï¼š');
  console.log('pi -> ', substituteParameters('pi'));
  console.log('2*pi -> ', substituteParameters('2*pi'));
  console.log('pi*2 -> ', substituteParameters('pi*2'));
  parameters.r = 5;
  console.log('pi*r (r=5) -> ', substituteParameters('pi*r'));
}

// ä»æ‹–åŠ¨çš„ç‚¹åå‘è®¡ç®—å‚æ•°å€¼
function updateParametersFromPoint(point) {
  if (!point.xExpr || !point.yExpr) return;
  
  // å°è¯•è§£æç®€å•çš„å‚æ•°è¡¨è¾¾å¼
  const xParams = extractParameters(point.xExpr);
  const yParams = extractParameters(point.yExpr);
  
  // å¯¹äºç®€å•æƒ…å†µï¼Œå¦‚æœè¡¨è¾¾å¼å°±æ˜¯å•ä¸ªå‚æ•°ï¼Œç›´æ¥æ›´æ–°
  if (xParams.length === 1 && point.xExpr.trim() === xParams[0]) {
    parameters[xParams[0]] = point.x;
  }
  if (yParams.length === 1 && point.yExpr.trim() === yParams[0]) {
    parameters[yParams[0]] = point.y;
  }
  
  // é‡æ–°æ¸²æŸ“å‚æ•°æ§åˆ¶åŒºåŸŸ
  renderParameterControls();
}

// å¤åŸæ‰€æœ‰ç‚¹åˆ°åŸå§‹ä½ç½®
function restoreOriginalPositions() {
  if (confirm('ç¡®å®šè¦å¤åŸæ‰€æœ‰ç‚¹åˆ°åˆå§‹çŠ¶æ€å—ï¼Ÿè¿™å°†é‡ç½®æ‰€æœ‰æ‹–åŠ¨çš„ä¿®æ”¹ã€‚')) {
    saveState(); // ä¿å­˜çŠ¶æ€ç”¨äºæ’¤é”€
    
    points.forEach(point => {
      point.isDragged = false;
      // é‡æ–°è®¡ç®—å‚æ•°åŒ–ç‚¹çš„ä½ç½®
      if (point.xExpr && point.yExpr) {
        try {
          point.x = eval(substituteParameters(point.xExpr));
          point.y = eval(substituteParameters(point.yExpr));
        } catch (e) {
          // å¦‚æœè®¡ç®—å¤±è´¥ï¼Œä¿æŒå½“å‰ä½ç½®
        }
      }
    });
    
    // å¤åŸæ‰€æœ‰æŠ›ç‰©çº¿
    parabolas.forEach(parabola => {
      if (parabola.originalState) {
        parabola.p = parabola.originalState.p;
        parabola.pExpr = parabola.originalState.pExpr;
        parabola.raw = parabola.originalState.raw;
        parabola.isDragged = false;
        parabola.dragOffset = null;
        parabola.transformedEquation = null;
      }
    });
    
    updateIntersections();
    redraw();
  }
}

// å¤åŸå•ä¸ªç‚¹
function restorePoint(index) {
  if (index >= 0 && index < points.length) {
    saveState(); // ä¿å­˜çŠ¶æ€ç”¨äºæ’¤é”€
    
    const point = points[index];
    point.isDragged = false;
    
    // é‡æ–°è®¡ç®—å‚æ•°åŒ–ç‚¹çš„ä½ç½®
    if (point.xExpr && point.yExpr) {
      try {
        point.x = eval(substituteParameters(point.xExpr));
        point.y = eval(substituteParameters(point.yExpr));
      } catch (e) {
        // å¦‚æœè®¡ç®—å¤±è´¥ï¼Œä¿æŒå½“å‰ä½ç½®
      }
    }
    
    updateIntersections();
    redraw();
  }
}

// å¤åŸå•ä¸ªæŠ›ç‰©çº¿
function restoreParabola(index) {
  if (index >= 0 && index < parabolas.length) {
    saveState(); // ä¿å­˜çŠ¶æ€ç”¨äºæ’¤é”€
    
    const parabola = parabolas[index];
    if (parabola.originalState) {
      parabola.p = parabola.originalState.p;
      parabola.pExpr = parabola.originalState.pExpr;
      parabola.raw = parabola.originalState.raw;
      parabola.isDragged = false;
      parabola.dragOffset = null;
      parabola.transformedEquation = null;
    }
    
    redraw();
  }
}

// é”®ç›˜æ§åˆ¶ç§»åŠ¨æŠ›ç‰©çº¿
function moveParabola(index, dx, dy) {
  if (index >= 0 && index < parabolas.length) {
    const parabola = parabolas[index];
    
    // ç¡®ä¿æœ‰åˆå§‹çŠ¶æ€è®°å½•
    if (!parabola.originalState) {
      parabola.originalState = {
        p: parabola.p,
        pExpr: parabola.pExpr,
        type: parabola.type,
        raw: parabola.raw
      };
    }
    
    // åˆå§‹åŒ–æˆ–æ›´æ–°æ‹–åŠ¨åç§»
    if (!parabola.dragOffset) {
      parabola.dragOffset = {x: 0, y: 0};
    }
    
    parabola.dragOffset.x += dx;
    parabola.dragOffset.y += dy;
    parabola.isDragged = true;
    
    // ç”Ÿæˆå¹³ç§»åçš„æ–¹ç¨‹
    generateTransformedEquation(parabola);
  }
}

// é”®ç›˜æ§åˆ¶ç§»åŠ¨ç‚¹
function movePoint(index, dx, dy) {
  if (index >= 0 && index < points.length) {
    const point = points[index];
    point.x += dx;
    point.y += dy;
    point.isDragged = true;
    
    // å¦‚æœæ˜¯å‚æ•°åŒ–çš„ç‚¹ï¼Œæ›´æ–°å¯¹åº”çš„å‚æ•°å€¼
    if (point.xExpr && point.yExpr) {
      updateParametersFromPoint(point);
    }
    
    // æ›´æ–°ç›¸å…³çš„åœ†
    for(let c of circles) {
      if(c.centerRef === point) {
        c.x = point.x;
        c.y = point.y;
      }
    }
    
    updateIntersections();
  }
}

// ç”Ÿæˆå¹³ç§»åçš„æ–¹ç¨‹
function generateTransformedEquation(curve) {
  if (!curve.dragOffset) return;
  
  const dx = curve.dragOffset.x;
  const dy = curve.dragOffset.y;
  
  if (curve.type === 'y2') {
    // åŸæ–¹ç¨‹ï¼šyÂ²=2pxï¼Œå¹³ç§»åï¼š(y-k)Â²=2p(x-h)
    let pValue = curve.pExpr || curve.p;
    
    // æ„å»ºå¹³ç§»åçš„æ–¹ç¨‹
    let equation = '';
    
    // å¤„ç† y é¡¹
    if (Math.abs(dy) < 0.01) {
      equation += 'yÂ²';
    } else if (dy > 0) {
      equation += `(y-${dy.toFixed(1)})Â²`;
    } else {
      equation += `(y+${Math.abs(dy).toFixed(1)})Â²`;
    }
    
    equation += '=';
    
    // å¤„ç† x é¡¹
    if (typeof pValue === 'string') {
      equation += `2*${pValue}*`;
    } else {
      equation += `${(2*pValue).toFixed(1)}*`;
    }
    
    if (Math.abs(dx) < 0.01) {
      equation += 'x';
    } else if (dx > 0) {
      equation += `(x-${dx.toFixed(1)})`;
    } else {
      equation += `(x+${Math.abs(dx).toFixed(1)})`;
    }
    
    curve.transformedEquation = equation;
    
  } else if (curve.type === 'x2') {
    // åŸæ–¹ç¨‹ï¼šxÂ²=2pyï¼Œå¹³ç§»åï¼š(x-h)Â²=2p(y-k)
    let pValue = curve.pExpr || curve.p;
    
    let equation = '';
    
    // å¤„ç† x é¡¹
    if (Math.abs(dx) < 0.01) {
      equation += 'xÂ²';
    } else if (dx > 0) {
      equation += `(x-${dx.toFixed(1)})Â²`;
    } else {
      equation += `(x+${Math.abs(dx).toFixed(1)})Â²`;
    }
    
    equation += '=';
    
    // å¤„ç† y é¡¹
    if (typeof pValue === 'string') {
      equation += `2*${pValue}*`;
    } else {
      equation += `${(2*pValue).toFixed(1)}*`;
    }
    
    if (Math.abs(dy) < 0.01) {
      equation += 'y';
    } else if (dy > 0) {
      equation += `(y-${dy.toFixed(1)})`;
    } else {
      equation += `(y+${Math.abs(dy).toFixed(1)})`;
    }
    
    curve.transformedEquation = equation;
  }
}

function addParameter(name, value = 1, min = -10, max = 10, step = 0.1) {
  if (!parameters.hasOwnProperty(name)) {
    parameters[name] = value;
    parameterRanges[name] = {min, max, step};
    renderParameterControls();
  }
}

function updateParameter(name, value) {
  if (parameters.hasOwnProperty(name)) {
    parameters[name] = parseFloat(value);
    redraw();
  }
}

function resetParameters() {
  parameters = {};
  parameterRanges = {};
  renderParameterControls();
  redraw();
}

function addCustomParameter() {
  const name = prompt("è¯·è¾“å…¥å‚æ•°åç§°ï¼ˆå•ä¸ªå­—æ¯ï¼Œå¦‚ a, b, m, n ç­‰ï¼‰:");
  if (name && /^[a-zA-Z]$/.test(name)) {
    const value = parseFloat(prompt("è¯·è¾“å…¥åˆå§‹å€¼:", "1")) || 1;
    addParameter(name, value);
  } else if (name) {
    alert("å‚æ•°åç§°å¿…é¡»æ˜¯å•ä¸ªå­—æ¯ï¼");
  }
}

function substituteParameters(expr) {
  if (!expr) return expr;
  let result = expr.toString();
  
  // å…ˆæ›¿æ¢æ•°å­¦å¸¸æ•°ï¼Œé¿å…è¢«åç»­å¤„ç†å½±å“
  result = result.replace(/\bpi\b/gi, 'Math.PI');
  result = result.replace(/\bÏ€\b/g, 'Math.PI');
  result = result.replace(/\be\b/g, 'Math.E');
  
  // å¤„ç†ä¹˜æ³•ç®€å†™ï¼ˆå¦‚ 5m -> 5*mï¼‰ï¼Œä½†è¦é¿å…å½±å“Math.PI
  result = result.replace(/(\d+)([a-zA-Z])/g, '$1*$2');
  // å¤„ç†ç›¸é‚»å­—æ¯ï¼ˆå¦‚ mn -> m*nï¼‰ï¼Œä½†è¦ä¿æŠ¤Math.PI
  result = result.replace(/([a-zA-Z])([a-zA-Z])/g, function(match, p1, p2) {
    // å¦‚æœæ˜¯Math.PIçš„ä¸€éƒ¨åˆ†ï¼Œä¸è¦æ‹†åˆ†
    if (match === 'th' || match === 'Ma' || match === 'at' || match === 'PI') {
      return match;
    }
    return p1 + '*' + p2;
  });
  
  for (let [name, value] of Object.entries(parameters)) {
    // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æ›¿æ¢å‚æ•°ï¼Œç¡®ä¿ä¸ä¼šæ›¿æ¢å‡½æ•°åçš„ä¸€éƒ¨åˆ†
    const regex = new RegExp('\\b' + name + '\\b', 'g');
    result = result.replace(regex, value.toString());
  }
  return result;
}

function renderParameterControls() {
  const container = document.getElementById('parameter-list');
  container.innerHTML = '';
  
  if (Object.keys(parameters).length === 0) {
    container.innerHTML = '<div style="color:#999;font-size:13px;">æš‚æ— å‚æ•°</div>';
    return;
  }
  
  for (let [name, value] of Object.entries(parameters)) {
    const range = parameterRanges[name];
    const div = document.createElement('div');
    div.className = 'parameter-item';
    div.innerHTML = `
      <label>${name}:</label>
      <input type="range" 
             min="${range.min}" 
             max="${range.max}" 
             step="${range.step}" 
             value="${value}"
             oninput="updateParameter('${name}', this.value); document.getElementById('param-${name}-value').value = this.value">
      <input type="number" 
             id="param-${name}-value"
             min="${range.min}" 
             max="${range.max}" 
             step="${range.step}" 
             value="${value}"
             oninput="updateParameter('${name}', this.value); this.previousElementSibling.value = this.value"
             onchange="updateParameter('${name}', this.value); this.previousElementSibling.value = this.value">
      <button onclick="resetParameter('${name}')" style="padding:2px 6px;font-size:12px;">é‡ç½®</button>
      <button onclick="removeParameter('${name}')" style="padding:2px 6px;font-size:12px;">Ã—</button>
    `;
    container.appendChild(div);
  }
}

function removeParameter(name) {
  delete parameters[name];
  delete parameterRanges[name];
  renderParameterControls();
  redraw();
}

function detectAndAddParameters(inputs) {
  const detectedParams = [];
  inputs.forEach(input => {
    if (typeof input === 'string') {
      const params = extractParameters(input);
      params.forEach(param => {
        if (!parameters.hasOwnProperty(param)) {
          addParameter(param);
          detectedParams.push(param);
        }
      });
    }
  });
  
  if (detectedParams.length > 0) {
    document.getElementById('parameter-hint').innerHTML = 
      `<div class="parameter-detected">æ£€æµ‹åˆ°æ–°å‚æ•°: ${detectedParams.join(', ')}</div>`;
    setTimeout(() => {
      document.getElementById('parameter-hint').innerHTML = '';
    }, 3000);
  }
}

// æ’¤é”€ç³»ç»Ÿå‡½æ•°
function saveState() {
  const state = {
    points: JSON.parse(JSON.stringify(points)),
    segments: JSON.parse(JSON.stringify(segments)),
    circles: JSON.parse(JSON.stringify(circles)),
    ellipses: JSON.parse(JSON.stringify(ellipses)),
    parabolas: JSON.parse(JSON.stringify(parabolas)),
    hyperbolas: JSON.parse(JSON.stringify(hyperbolas)),
    polars: JSON.parse(JSON.stringify(polars)),
    functions: JSON.parse(JSON.stringify(functions)),
    intersectionPoints: JSON.parse(JSON.stringify(intersectionPoints)),
    intersectionLines: JSON.parse(JSON.stringify(intersectionLines)),
    parameters: JSON.parse(JSON.stringify(parameters)),
    parameterRanges: JSON.parse(JSON.stringify(parameterRanges))
  };
  
  operationHistory.push(state);
  if (operationHistory.length > maxHistorySize) {
    operationHistory.shift();
  }
}

function undo() {
  if (operationHistory.length > 0) {
    const state = operationHistory.pop();
    points = state.points;
    segments = state.segments;
    circles = state.circles;
    ellipses = state.ellipses;
    parabolas = state.parabolas;
    hyperbolas = state.hyperbolas;
    polars = state.polars;
    functions = state.functions;
    intersectionPoints = state.intersectionPoints;
    intersectionLines = state.intersectionLines;
    parameters = state.parameters;
    parameterRanges = state.parameterRanges;
    
    renderParameterControls();
    redraw();
  }
}

// åˆ é™¤å‡½æ•°
function deletePoint(index) {
  if (skipDeleteConfirm) {
    doDeletePoint(index);
    return;
  }
  showDeleteConfirm('åˆ é™¤æ­¤ç‚¹ä¼šåŒæ—¶åˆ é™¤ç›¸å…³çš„çº¿æ®µå’Œç›´çº¿ï¼Œç¡®å®šè¦åˆ é™¤å—ï¼Ÿ', function(checked) {
    if (checked) skipDeleteConfirm = true;
    doDeletePoint(index);
  });
}

function doDeletePoint(index) {
  saveState();
  const pointToDelete = points[index];
  segments = segments.filter(seg => seg.p1 !== pointToDelete && seg.p2 !== pointToDelete);
  intersectionLines = intersectionLines.filter(line => line.p1 !== pointToDelete && line.p2 !== pointToDelete);
  circles = circles.filter(c => c.centerRef !== pointToDelete);
  points.splice(index, 1);
  selectedPointIdx = null;
  updateIntersections();
  redraw();
}

function deleteSegment(index) {
  if (skipDeleteConfirm) {
    doDeleteSegment(index);
    return;
  }
  showDeleteConfirm('ç¡®å®šè¦åˆ é™¤æ­¤çº¿æ®µå—ï¼Ÿ', function(checked) {
    if (checked) skipDeleteConfirm = true;
    doDeleteSegment(index);
  });
}

function doDeleteSegment(index) {
  saveState();
  segments.splice(index, 1);
  updateIntersections();
  redraw();
}

function deleteLine(index) {
  if (skipDeleteConfirm) {
    doDeleteLine(index);
    return;
  }
  showDeleteConfirm('ç¡®å®šè¦åˆ é™¤æ­¤ç›´çº¿å—ï¼Ÿ', function(checked) {
    if (checked) skipDeleteConfirm = true;
    doDeleteLine(index);
  });
}

function doDeleteLine(index) {
  saveState();
  intersectionLines.splice(index, 1);
  redraw();
}

function deleteCircle(index) {
  if (skipDeleteConfirm) {
    doDeleteCircle(index);
    return;
  }
  showDeleteConfirm('ç¡®å®šè¦åˆ é™¤æ­¤åœ†å—ï¼Ÿ', function(checked) {
    if (checked) skipDeleteConfirm = true;
    doDeleteCircle(index);
  });
}

function doDeleteCircle(index) {
  saveState();
  circles.splice(index, 1);
  updateIntersections();
  redraw();
}

function deleteFunction(index) {
  if (skipDeleteConfirm) {
    doDeleteFunction(index);
    return;
  }
  showDeleteConfirm('ç¡®å®šè¦åˆ é™¤æ­¤å‡½æ•°å—ï¼Ÿ', function(checked) {
    if (checked) skipDeleteConfirm = true;
    doDeleteFunction(index);
  });
}

function doDeleteFunction(index) {
  saveState();
  functions.splice(index, 1);
  updateIntersections();
  redraw();
}

function deleteEllipse(index) {
  if (skipDeleteConfirm) {
    doDeleteEllipse(index);
    return;
  }
  showDeleteConfirm('ç¡®å®šè¦åˆ é™¤æ­¤æ¤­åœ†å—ï¼Ÿ', function(checked) {
    if (checked) skipDeleteConfirm = true;
    doDeleteEllipse(index);
  });
}

function doDeleteEllipse(index) {
  saveState();
  ellipses.splice(index, 1);
  redraw();
}

function deleteParabola(index) {
  if (skipDeleteConfirm) {
    doDeleteParabola(index);
    return;
  }
  showDeleteConfirm('ç¡®å®šè¦åˆ é™¤æ­¤æŠ›ç‰©çº¿å—ï¼Ÿ', function(checked) {
    if (checked) skipDeleteConfirm = true;
    doDeleteParabola(index);
  });
}

function doDeleteParabola(index) {
  saveState();
  parabolas.splice(index, 1);
  redraw();
}

function deleteHyperbola(index) {
  if (skipDeleteConfirm) {
    doDeleteHyperbola(index);
    return;
  }
  showDeleteConfirm('ç¡®å®šè¦åˆ é™¤æ­¤åŒæ›²çº¿å—ï¼Ÿ', function(checked) {
    if (checked) skipDeleteConfirm = true;
    doDeleteHyperbola(index);
  });
}

function doDeleteHyperbola(index) {
  saveState();
  hyperbolas.splice(index, 1);
  redraw();
}

function deletePolar(index) {
  if (skipDeleteConfirm) {
    doDeletePolar(index);
    return;
  }
  showDeleteConfirm('ç¡®å®šè¦åˆ é™¤æ­¤æåæ ‡æ›²çº¿å—ï¼Ÿ', function(checked) {
    if (checked) skipDeleteConfirm = true;
    doDeletePolar(index);
  });
}

function doDeletePolar(index) {
  saveState();
  polars.splice(index, 1);
  redraw();
}

// é€šç”¨åˆ é™¤ç¡®è®¤å¼¹çª—
function showDeleteConfirm(msg, callback) {
  // åˆ›å»ºé®ç½©
  let mask = document.createElement('div');
  mask.style.position = 'fixed';
  mask.style.left = '0';
  mask.style.top = '0';
  mask.style.width = '100vw';
  mask.style.height = '100vh';
  mask.style.background = 'rgba(0,0,0,0.08)';
  mask.style.zIndex = 9999;
  // åˆ›å»ºå¼¹çª—
  let box = document.createElement('div');
  box.style.position = 'fixed';
  box.style.left = '50%';
  box.style.top = '20%';
  box.style.transform = 'translate(-50%, 0)';
  box.style.background = '#fff';
  box.style.borderRadius = '8px';
  box.style.boxShadow = '0 4px 24px #aaa';
  box.style.padding = '28px 32px 18px 32px';
  box.style.minWidth = '320px';
  box.style.textAlign = 'center';
  box.style.zIndex = 10000;
  box.innerHTML = `
    <div style="font-size:18px;font-weight:bold;margin-bottom:10px;">åˆ é™¤ç¡®è®¤</div>
    <div style="font-size:15px;margin-bottom:18px;">${msg}</div>
    <label style="font-size:14px;display:inline-flex;align-items:center;gap:4px;margin-bottom:10px;">
      <input type="checkbox" id="skip-delete-confirm"> ä¹‹åä¸å†æç¤º
    </label><br>
    <button id="delete-confirm-ok" style="font-size:15px;padding:4px 18px;margin-right:16px;">ç¡®å®š</button>
    <button id="delete-confirm-cancel" style="font-size:15px;padding:4px 18px;">å–æ¶ˆ</button>
  `;
  document.body.appendChild(mask);
  document.body.appendChild(box);
  document.getElementById('delete-confirm-ok').onclick = function() {
    let checked = document.getElementById('skip-delete-confirm').checked;
    document.body.removeChild(mask);
    document.body.removeChild(box);
    callback(checked);
  };
  document.getElementById('delete-confirm-cancel').onclick = function() {
    document.body.removeChild(mask);
    document.body.removeChild(box);
  };
}

function switchMode(m) {
  mode = m;
  document.querySelectorAll('.toolbar button').forEach(btn=>btn.classList.remove('active-btn'));
  if(document.getElementById('btn-' + m))
    document.getElementById('btn-' + m).classList.add('active-btn');
  tempSegment = [];
  tempCircle = [];
  tempLine = [];
  // ä½œç›´çº¿æ¨¡å¼åˆå§‹åŒ–
  if(m === 'line') {
    lineSelectPoints = [];
    lineSelectActive = true;
  } else {
    lineSelectPoints = [];
    lineSelectActive = false;
  }
  renderInputArea();
  if(mode==='move') {
    canvas.style.cursor = 'grab';
  } else if(mode==='drag') {
    canvas.style.cursor = 'pointer';
  } else if(mode==='point') {
    canvas.style.cursor = 'crosshair';
  } else if(mode==='line') {
    canvas.style.cursor = 'pointer';
  } else {
    canvas.style.cursor = 'default';
  }
}

// ä¸‹æ‹‰èœå•é€»è¾‘
let functionType = 'equation';
document.addEventListener('click', function(e) {
  if(!e.target.closest('.dropdown')) {
    document.getElementById('function-menu').style.display = 'none';
  }
});

function toggleFunctionMenu() {
  const menu = document.getElementById('function-menu');
  menu.style.display = (menu.style.display==='block') ? 'none' : 'block';
}

document.querySelectorAll('#function-menu .dropdown-item').forEach(item => {
  item.onclick = function(e) {
    functionType = this.getAttribute('data-type');
    document.getElementById('function-menu').style.display = 'none';
    switchMode('function');
    renderInputArea();
  };
});

function renderInputArea() {
  const area = document.getElementById('input-area');
  const label = document.getElementById('function-type-label');
  // æ–°å¢ï¼šç±»å‹ä¸­æ–‡åæ˜ å°„
  const typeMap = {
    'circle': 'åœ†',
    'ellipse': 'æ¤­åœ†',
    'parabola': 'æŠ›ç‰©çº¿',
    'hyperbola': 'åŒæ›²çº¿',
    'polar': 'æåæ ‡',
    'equation': 'æ–¹ç¨‹/å‡½æ•°'
  };
  if(mode==='function') {
    label.textContent = 'å½“å‰ç±»å‹ï¼šå«å‚' + (typeMap[functionType] || 'æ–¹ç¨‹/å‡½æ•°');
  } else {
    label.textContent = '';
  }
  
  if(mode==='point') {
    area.innerHTML = `
      <input id="input-x" type="text" placeholder="xåæ ‡ (å¯ç”¨å‚æ•°ã€eã€Ï€/pi)" style="width:100px;">
      <input id="input-y" type="text" placeholder="yåæ ‡ (å¯ç”¨å‚æ•°ã€eã€Ï€/pi)" style="width:100px;">
      <button onclick="addPointByInput()">æ·»åŠ ç‚¹</button>
    `;
  } else if(mode==='segment') {
    area.innerHTML = `
      <input id="input-x1" type="text" placeholder="xâ‚ (å¯ç”¨å‚æ•°ã€eã€Ï€)" style="width:80px;">
      <input id="input-y1" type="text" placeholder="yâ‚ (å¯ç”¨å‚æ•°ã€eã€Ï€)" style="width:80px;">
      <input id="input-x2" type="text" placeholder="xâ‚‚ (å¯ç”¨å‚æ•°ã€eã€Ï€)" style="width:80px;">
      <input id="input-y2" type="text" placeholder="yâ‚‚ (å¯ç”¨å‚æ•°ã€eã€Ï€)" style="width:80px;">
      <button onclick="addSegmentByInput()">æ·»åŠ çº¿æ®µ</button>
    `;
  } else if(mode==='function') {
    if(functionType==='circle') {
      area.innerHTML = `
        <input id="input-x" type="text" placeholder="åœ†å¿ƒx (å¯ç”¨å‚æ•°ã€eã€Ï€)" style="width:120px;">
        <input id="input-y" type="text" placeholder="åœ†å¿ƒy (å¯ç”¨å‚æ•°ã€eã€Ï€)" style="width:120px;">
        <input id="input-r" type="text" placeholder="åŠå¾„ (å¯ç”¨å‚æ•°ã€eã€Ï€)" style="width:120px;">
        <button onclick="addCircleByInput()">æ·»åŠ åœ†</button>
      `;
    } else if(functionType==='ellipse') {
      area.innerHTML = `
        <input id="input-x" type="text" placeholder="ä¸­å¿ƒx (å¯ç”¨å‚æ•°ã€eã€Ï€)" style="width:100px;">
        <input id="input-y" type="text" placeholder="ä¸­å¿ƒy (å¯ç”¨å‚æ•°ã€eã€Ï€)" style="width:100px;">
        <input id="input-a" type="text" placeholder="a (å¯ç”¨å‚æ•°ã€eã€Ï€)" style="width:100px;">
        <input id="input-b" type="text" placeholder="b (å¯ç”¨å‚æ•°ã€eã€Ï€)" style="width:100px;">
        <button onclick="addEllipseByInput()">æ·»åŠ æ¤­åœ†</button>
      `;
    } else if(functionType==='parabola') {
      area.innerHTML = `
        <select id="parabola-type" style="width:90px;">
          <option value="y2">yÂ²=2px</option>
          <option value="x2">xÂ²=2py</option>
        </select>
        <input id="input-p" type="text" placeholder="p (å¯ç”¨å‚æ•°ã€eã€Ï€)" style="width:100px;">
        <button onclick="addParabolaByInput()">æ·»åŠ æŠ›ç‰©çº¿</button>
      `;
    } else if(functionType==='hyperbola') {
      area.innerHTML = `
        <input id="input-x" type="text" placeholder="ä¸­å¿ƒx (å¯ç”¨å‚æ•°ã€eã€Ï€)" style="width:100px;">
        <input id="input-y" type="text" placeholder="ä¸­å¿ƒy (å¯ç”¨å‚æ•°ã€eã€Ï€)" style="width:100px;">
        <input id="input-a" type="text" placeholder="a (å¯ç”¨å‚æ•°ã€eã€Ï€)" style="width:100px;">
        <input id="input-b" type="text" placeholder="b (å¯ç”¨å‚æ•°ã€eã€Ï€)" style="width:100px;">
        <select id="hyperbola-type" style="width:90px;">
          <option value="x">xè½´æ–¹å‘</option>
          <option value="y">yè½´æ–¹å‘</option>
        </select>
        <button onclick="addHyperbolaByInput()">æ·»åŠ åŒæ›²çº¿</button>
      `;
    } else if(functionType==='polar') {
      area.innerHTML = `
        <input id="input-polar" type="text" placeholder="å¦‚ r=a+b*sin(c*theta) (å¯ç”¨eã€Ï€)" style="width:280px;">
        <button onclick="addPolarByInput()">ç»˜åˆ¶æåæ ‡æ›²çº¿</button>
      `;
    } else {
      area.innerHTML = `
        <input id="input-func" type="text" placeholder="å¦‚ y=a*x^2+b æˆ– x^2/a+y^2/b=1 (å¯ç”¨eã€Ï€)" style="width:300px;">
        <button onclick="addFunction()">ç»˜åˆ¶æ–¹ç¨‹</button>
      `;
    }
  } else if(mode==='line') {
    let btns = '';
    if(lineSelectPoints.length === 2) {
      btns = `<button onclick="confirmLine()">ç¡®å®š</button> <button onclick="cancelLineSelect()">å–æ¶ˆ</button>`;
    } else if(lineSelectPoints.length === 1) {
      btns = `<button onclick="cancelLineSelect()">å–æ¶ˆ</button>`;
    }
    area.innerHTML = `<span>ä¾æ¬¡ç‚¹å‡»ä¸¤ä¸ªç‚¹ï¼ˆé«˜äº®ï¼‰ä½œç›´çº¿</span> ${btns}`;
      } else if(mode==='move') {
      area.innerHTML = `<div style='color:#888;font-size:15px;margin:8px 0 0 0;'>æç¤ºï¼šæ‹–åŠ¨å¯ç§»åŠ¨ç”»å¸ƒè§†è§’ï¼Œæ»šè½®æˆ–æŒ‰ä½ <b>Shift</b> æ‹–åŠ¨å¯ç¼©æ”¾</div>`;
    } else if(mode==='drag') {
      area.innerHTML = `<div style='color:#888;font-size:15px;margin:8px 0 0 0;'>æç¤ºï¼šç‚¹å‡»é€‰ä¸­è¦æ‹–åŠ¨çš„ç‚¹æˆ–å‡ ä½•å¯¹è±¡ï¼Œç„¶åæ‹–åŠ¨æ”¹å˜ä½ç½®ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨å°é”®ç›˜ä¸Šä¸‹å·¦å³æŒ‰é”®ç§»åŠ¨</div>`;
    }
}

function toggleClickAddPoint() {
  // è¯¥å‡½æ•°å·²åºŸå¼ƒï¼Œæ— éœ€å®ç°
}

function getAdaptiveStep(scale) {
  const targetPx = 80;
  const steps = [1, 2, 5, 10];
  let base = Math.pow(10, Math.floor(Math.log10(1/scale*targetPx)));
  let bestStep = base, minDiff = Infinity;
  for (let s of steps) {
    let step = base * s;
    let px = step * scale;
    let diff = Math.abs(px - targetPx);
    if (diff < minDiff && px > 30) {
      minDiff = diff;
      bestStep = step;
    }
  }
  if (bestStep < 1) bestStep = Math.round(bestStep * 100) / 100;
  return bestStep;
}

function drawAxes() {
  ctx.save();
  let mainStep = getAdaptiveStep(scale);
  let subStep = mainStep / 5;
  if(showGrid) {
    ctx.strokeStyle = '#eee';
    ctx.lineWidth = 1;
    // æ¨ªå‘æ¬¡ç½‘æ ¼
    let xStart = toMathX(0), xEnd = toMathX(width);
    let yStart = toMathY(height), yEnd = toMathY(0);
    for(let x = Math.ceil(xStart/subStep)*subStep; x <= xEnd; x += subStep) {
      if(Math.abs(x/mainStep-Math.round(x/mainStep))<1e-6) continue;
      ctx.beginPath();
      ctx.moveTo(toCanvasX(x), 0);
      ctx.lineTo(toCanvasX(x), height);
      ctx.stroke();
    }
    for(let y = Math.ceil(yStart/subStep)*subStep; y <= yEnd; y += subStep) {
      if(Math.abs(y/mainStep-Math.round(y/mainStep))<1e-6) continue;
      ctx.beginPath();
      ctx.moveTo(0, toCanvasY(y));
      ctx.lineTo(width, toCanvasY(y));
      ctx.stroke();
    }
    // ç”»ä¸»ç½‘æ ¼
    ctx.strokeStyle = '#ddd';
    ctx.lineWidth = 1.5;
    for(let x = Math.ceil(xStart/mainStep)*mainStep; x <= xEnd; x += mainStep) {
      ctx.beginPath();
      ctx.moveTo(toCanvasX(x), 0);
      ctx.lineTo(toCanvasX(x), height);
      ctx.stroke();
    }
    for(let y = Math.ceil(yStart/mainStep)*mainStep; y <= yEnd; y += mainStep) {
      ctx.beginPath();
      ctx.moveTo(0, toCanvasY(y));
      ctx.lineTo(width, toCanvasY(y));
      ctx.stroke();
    }
  }
  // ç”»åæ ‡è½´
  ctx.strokeStyle = '#444';
  ctx.lineWidth = 3;
  // åˆ¤æ–­xè½´/yè½´æ˜¯å¦åœ¨å¯è§èŒƒå›´
  let xAxisInView = toCanvasY(0) >= 0 && toCanvasY(0) <= height;
  let yAxisInView = toCanvasX(0) >= 0 && toCanvasX(0) <= width;
  if(xAxisInView) ctx.beginPath(),ctx.moveTo(0,toCanvasY(0)),ctx.lineTo(width,toCanvasY(0)),ctx.stroke();
  if(yAxisInView) ctx.beginPath(),ctx.moveTo(toCanvasX(0),0),ctx.lineTo(toCanvasX(0),height),ctx.stroke();
  // åŸç‚¹é«˜äº®
  if(xAxisInView && yAxisInView) {
    ctx.beginPath();
    ctx.arc(toCanvasX(0), toCanvasY(0), 7, 0, 2*Math.PI);
    ctx.fillStyle = '#f00';
    ctx.fill();
  }
  // ä¸»åˆ»åº¦æ•°å­—ï¼ˆåªæ˜¾ç¤ºåœ¨å¯è§åŒºåŸŸï¼‰
  ctx.fillStyle = '#222';
  ctx.font = '13px Arial';
  let xMin = toMathX(0), xMax = toMathX(width);
  let yMin = toMathY(height), yMax = toMathY(0);
  // xè½´ä¸»åˆ»åº¦
  let xStart = Math.ceil(xMin / mainStep) * mainStep;
  for(let x = xStart; x <= xMax; x += mainStep) {
    if(Math.abs(x)<1e-6) continue;
    let px = toCanvasX(x);
    if(px < 0 || px > width) continue;
    ctx.beginPath();
    ctx.moveTo(px, toCanvasY(0)-8);
    ctx.lineTo(px, toCanvasY(0)+8);
    ctx.strokeStyle = '#444';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.fillText(x.toFixed(mainStep<1?2:1), px - 10, toCanvasY(0) + 22);
  }
  // yè½´ä¸»åˆ»åº¦
  let yStart = Math.ceil(yMin / mainStep) * mainStep;
  for(let y = yStart; y <= yMax; y += mainStep) {
    if(Math.abs(y)<1e-6) continue;
    let py = toCanvasY(y);
    if(py < 0 || py > height) continue;
    ctx.beginPath();
    ctx.moveTo(toCanvasX(0)-8, py);
    ctx.lineTo(toCanvasX(0)+8, py);
    ctx.strokeStyle = '#444';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.fillText(y.toFixed(mainStep<1?2:1), toCanvasX(0) + 10, py + 4);
  }
  // è¾¹ç•Œä¸»åˆ»åº¦æ•°å­—ï¼ˆé£æ ¼ä¸ä¸»åˆ»åº¦ä¸€è‡´ï¼‰
  ctx.fillStyle = '#222';
  ctx.font = '13px Arial';
  // yè½´ä¸åœ¨å¯è§èŒƒå›´ï¼Œå·¦è¾¹æ•´æ¡è¾¹æ ‡æ³¨yä¸»åˆ»åº¦
  if(!yAxisInView) {
    for(let y = yStart; y <= yMax; y += mainStep) {
      if(Math.abs(y)<1e-6) continue;
      let py = toCanvasY(y);
      if(py < 0 || py > height) continue;
      ctx.fillText(y.toFixed(mainStep<1?2:1), 10, py + 4);
    }
  }
  // xè½´ä¸åœ¨å¯è§èŒƒå›´ï¼Œä¸‹è¾¹æ•´æ¡è¾¹æ ‡æ³¨xä¸»åˆ»åº¦
  if(!xAxisInView) {
    for(let x = xStart; x <= xMax; x += mainStep) {
      if(Math.abs(x)<1e-6) continue;
      let px = toCanvasX(x);
      if(px < 0 || px > width) continue;
      ctx.fillText(x.toFixed(mainStep<1?2:1), px - 10, height - 8);
    }
  }
  ctx.restore();
}

function drawPoints() {
  ctx.save();
  points.forEach((pt, idx) => {
    // è®¡ç®—å‚æ•°åŒ–åæ ‡
    let x, y;
    try {
      if (pt.xExpr && pt.yExpr && !pt.isDragged) {
        x = eval(substituteParameters(pt.xExpr));
        y = eval(substituteParameters(pt.yExpr));
      } else {
        x = pt.x;
        y = pt.y;
      }
    } catch {
      x = pt.x;
      y = pt.y;
    }
    
    ctx.beginPath();
    ctx.arc(toCanvasX(x), toCanvasY(y), 7, 0, 2*Math.PI);
    let isLineSelected = (mode==='line' && lineSelectPoints.includes(pt));
    // æ‹–åŠ¨è¿‡çš„ç‚¹æ˜¾ç¤ºä¸ºç»¿è‰²
    let pointColor = pt.isDragged ? '#27ae60' : '#3498db';
    ctx.fillStyle = isLineSelected ? '#f90' : (selectedPointIdx===idx ? '#f90' : pointColor);
    ctx.fill();
    ctx.strokeStyle = '#333';
    ctx.lineWidth = (selectedPointIdx===idx) ? 3 : 1.5;
    ctx.stroke();
    ctx.fillStyle = '#222';
    ctx.font = 'bold 15px Arial';
    ctx.textAlign = (toCanvasX(x) < width/2) ? 'left' : 'right';
    ctx.fillText(String.fromCharCode(65+idx), toCanvasX(x)+(toCanvasX(x)<width/2?15:-15), toCanvasY(y)-10);
    
    // æ›´æ–°ç‚¹çš„å®é™…åæ ‡
    pt.x = x;
    pt.y = y;
  });
  ctx.restore();
}

function drawSegments() {
  ctx.save();
  ctx.strokeStyle = '#e74c3c';
  ctx.lineWidth = 2;
  segments.forEach((seg, idx) => {
    ctx.beginPath();
    ctx.moveTo(toCanvasX(seg.p1.x), toCanvasY(seg.p1.y));
    ctx.lineTo(toCanvasX(seg.p2.x), toCanvasY(seg.p2.y));
    ctx.stroke();
  });
  ctx.restore();
}

function drawCircles() {
  ctx.save();
  circles.forEach((c, idx) => {
    // è®¡ç®—å‚æ•°åŒ–å±æ€§
    let x, y, r;
    try {
      if (c.xExpr && c.yExpr && c.rExpr) {
        x = eval(substituteParameters(c.xExpr));
        y = eval(substituteParameters(c.yExpr));
        r = eval(substituteParameters(c.rExpr));
      } else {
        x = c.x;
        y = c.y;
        r = c.r;
      }
    } catch {
      x = c.x;
      y = c.y;
      r = c.r;
    }
    ctx.beginPath();
    ctx.arc(toCanvasX(x), toCanvasY(y), Math.abs(r)*scale, 0, 2*Math.PI);
    if(selectedCircleIdx === idx) {
      ctx.strokeStyle = '#f90';
      ctx.lineWidth = 4;
    } else {
      ctx.strokeStyle = '#27ae60';
      ctx.lineWidth = 2;
    }
    ctx.stroke();
    // æ›´æ–°åœ†çš„å®é™…å±æ€§
    c.x = x;
    c.y = y;
    c.r = r;
  });
  ctx.restore();
}

function drawEllipses() {
  ctx.save();
  ctx.strokeStyle = '#2980b9';
  ctx.lineWidth = 2;
  ellipses.forEach(e => {
    // è®¡ç®—å‚æ•°åŒ–å±æ€§
    let x, y, a, b;
    try {
      if (e.xExpr && e.yExpr && e.aExpr && e.bExpr) {
        x = eval(substituteParameters(e.xExpr));
        y = eval(substituteParameters(e.yExpr));
        a = eval(substituteParameters(e.aExpr));
        b = eval(substituteParameters(e.bExpr));
      } else {
        x = e.x;
        y = e.y;
        a = e.a;
        b = e.b;
      }
    } catch {
      x = e.x;
      y = e.y;
      a = e.a;
      b = e.b;
    }
    
    ctx.beginPath();
    for(let t=0;t<=2*Math.PI+0.01;t+=0.01) {
      let px = x + a * Math.cos(t);
      let py = y + b * Math.sin(t);
      let cx = toCanvasX(px), cy = toCanvasY(py);
      if(t===0) ctx.moveTo(cx, cy); else ctx.lineTo(cx, cy);
    }
    ctx.closePath();
    ctx.stroke();
  });
  ctx.restore();
}

function drawFunctions() {
  ctx.save();
  functions.forEach((fobj, idx) => {
    let expr = substituteParameters(fobj.expr);
    try {
      let xMin = toMathX(0), xMax = toMathX(width);
      let step = Math.max(0.01, (xMax-xMin)/1000);
      ctx.save();
      ctx.beginPath();
      let first = true;
      for(let x = xMin; x <= xMax; x += step) {
        let y;
        try { y = eval(expr); } catch { continue; }
        if(typeof y !== 'number' || !isFinite(y)) continue;
        let px = toCanvasX(x);
        let py = toCanvasY(y);
        if(first) { ctx.moveTo(px, py); first = false; }
        else ctx.lineTo(px, py);
      }
      if(selectedFunctionIdx === idx) {
        ctx.strokeStyle = '#f90'; // æ©™è‰²ï¼Œä¸ç‚¹é«˜äº®ä¸€è‡´
        ctx.lineWidth = 4;
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
      } else {
        ctx.strokeStyle = '#e67e22';
        ctx.lineWidth = 2;
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
      }
      ctx.stroke();
      ctx.restore();
    } catch {}
  });
  ctx.restore();
}

function drawIntersectionPoints() {
  ctx.save();
  intersectionPoints.forEach((pt, idx) => {
    ctx.beginPath();
    ctx.arc(toCanvasX(pt.x), toCanvasY(pt.y), 6, 0, 2*Math.PI);
    ctx.fillStyle = '#e67e22';
    ctx.fill();
    ctx.strokeStyle = '#d35400';
    ctx.lineWidth = 2;
    ctx.stroke();
    ctx.fillStyle = '#d35400';
    ctx.fillText('äº¤ç‚¹'+(idx+1), toCanvasX(pt.x)+10, toCanvasY(pt.y)-10);
  });
  ctx.restore();
}

function drawIntersectionLines() {
  ctx.save();
  intersectionLines.forEach((line, idx) => {
    let dx = line.p2.x - line.p1.x;
    let dy = line.p2.y - line.p1.y;
    if(dx === 0 && dy === 0) return;
    // è®¡ç®—ç›´çº¿ä¸ç”»å¸ƒå››è¾¹çš„äº¤ç‚¹
    let points = [];
    // ä¸Šè¾¹ y=0
    {
      let y = toMathY(0);
      if(Math.abs(dy) > 1e-8) {
        let t = (y - line.p1.y) / dy;
        let x = line.p1.x + t * dx;
        let px = toCanvasX(x), py = toCanvasY(y);
        if(px >= 0 && px <= width) points.push({x, y});
      }
    }
    // ä¸‹è¾¹ y=height
    {
      let y = toMathY(height);
      if(Math.abs(dy) > 1e-8) {
        let t = (y - line.p1.y) / dy;
        let x = line.p1.x + t * dx;
        let px = toCanvasX(x), py = toCanvasY(y);
        if(px >= 0 && px <= width) points.push({x, y});
      }
    }
    // å·¦è¾¹ x=0
    {
      let x = toMathX(0);
      if(Math.abs(dx) > 1e-8) {
        let t = (x - line.p1.x) / dx;
        let y = line.p1.y + t * dy;
        let px = toCanvasX(x), py = toCanvasY(y);
        if(py >= 0 && py <= height) points.push({x, y});
      }
    }
    // å³è¾¹ x=width
    {
      let x = toMathX(width);
      if(Math.abs(dx) > 1e-8) {
        let t = (x - line.p1.x) / dx;
        let y = line.p1.y + t * dy;
        let px = toCanvasX(x), py = toCanvasY(y);
        if(py >= 0 && py <= height) points.push({x, y});
      }
    }
    // å–æœ€è¿œçš„ä¸¤ä¸ªäº¤ç‚¹
    if(points.length >= 2) {
      // è®¡ç®—ä¸¤ä¸¤è·ç¦»ï¼Œå–æœ€è¿œçš„ä¸¤ä¸ª
      let maxDist = 0, pA = points[0], pB = points[1];
      for(let i=0;i<points.length;i++){
        for(let j=i+1;j<points.length;j++){
          let d = Math.hypot(points[i].x-points[j].x, points[i].y-points[j].y);
          if(d > maxDist) { maxDist = d; pA = points[i]; pB = points[j]; }
        }
      }
      ctx.save();
      ctx.strokeStyle = '#6c3483';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(toCanvasX(pA.x), toCanvasY(pA.y));
      ctx.lineTo(toCanvasX(pB.x), toCanvasY(pB.y));
      ctx.stroke();
      // æ ‡æ³¨ç›´çº¿æ–¹ç¨‹åœ¨ä¸­ç‚¹é™„è¿‘
      let mx = (pA.x + pB.x) / 2;
      let my = (pA.y + pB.y) / 2;
      let eq = getLineEquation(line.p1, line.p2);
      ctx.font = '13px Arial';
      ctx.fillStyle = '#6c3483';
      ctx.fillText(eq, toCanvasX(mx) + 10, toCanvasY(my) - 10);
      ctx.restore();
    }
  });
  ctx.restore();
}

function drawParabolas() {
  ctx.save();
  parabolas.forEach((pb, idx) => {
    // æ‹–åŠ¨è¿‡çš„æŠ›ç‰©çº¿æ˜¾ç¤ºä¸ºç»¿è‰²ï¼Œé€‰ä¸­çš„æ˜¾ç¤ºä¸ºæ©™è‰²
    let strokeColor = '#8e44ad';
    if (pb.isDragged) strokeColor = '#27ae60';
    if (selectedParabolaIdx === idx) strokeColor = '#f90';
    
    ctx.strokeStyle = strokeColor;
    ctx.lineWidth = (selectedParabolaIdx === idx) ? 4 : 2;
    
    // è®¡ç®—å‚æ•°åŒ–å±æ€§
    let p;
    try {
      if (pb.pExpr) {
        p = eval(substituteParameters(pb.pExpr));
      } else {
        p = pb.p;
      }
    } catch {
      p = pb.p;
    }
    
    // è®¡ç®—å¹³ç§»é‡
    const offsetX = pb.dragOffset ? pb.dragOffset.x : 0;
    const offsetY = pb.dragOffset ? pb.dragOffset.y : 0;
    
    // æ ¹æ®è§†å›¾èŒƒå›´åŠ¨æ€è°ƒæ•´ç»˜åˆ¶èŒƒå›´
    let xMin = toMathX(0), xMax = toMathX(width);
    let yMin = toMathY(height), yMax = toMathY(0);
    let maxRange = Math.max(Math.abs(xMax-xMin), Math.abs(yMax-yMin)) * 1.5;
    
    if(pb.type==='y2') {
      // yÂ²=2pxï¼Œå¹³ç§»åï¼š(y-k)Â²=2p(x-h)
      ctx.beginPath();
      let first = true;
      
      // æ‰©å¤§ç»˜åˆ¶èŒƒå›´ï¼Œç¡®ä¿è¦†ç›–æ•´ä¸ªè§†å›¾
      let viewRange = maxRange * 2;
      
      if(p > 0) {
        // p>0æ—¶ï¼Œå¼€å£å‘å³ï¼Œä»é¡¶ç‚¹å¼€å§‹ç»˜åˆ¶
        let startX = 0; // æŠ›ç‰©çº¿çš„é¡¶ç‚¹åœ¨x=0
        let endX = viewRange;
        
        // ç»˜åˆ¶ä¸ŠåŠæ”¯
        for(let x = startX; x <= endX; x += 0.02) {
          let y1 = Math.sqrt(2*p*x);
          if(isFinite(y1)) {
            let cx = toCanvasX(x + offsetX), cy1 = toCanvasY(y1 + offsetY);
            if(first) { 
              ctx.moveTo(cx, cy1); 
              first = false; 
            } else {
              ctx.lineTo(cx, cy1);
            }
          }
        }
        // ç»˜åˆ¶ä¸‹åŠæ”¯
        for(let x = endX; x >= startX; x -= 0.02) {
          let y = -Math.sqrt(2*p*x);
          if(isFinite(y)) {
            let cx = toCanvasX(x + offsetX), cy = toCanvasY(y + offsetY);
            ctx.lineTo(cx, cy);
          }
        }
      } else {
        // p<0æ—¶ï¼Œå¼€å£å‘å·¦ï¼Œä»é¡¶ç‚¹å¼€å§‹ç»˜åˆ¶
        let startX = 0; // æŠ›ç‰©çº¿çš„é¡¶ç‚¹åœ¨x=0
        let endX = -viewRange;
        
        // ç»˜åˆ¶ä¸ŠåŠæ”¯
        for(let x = startX; x >= endX; x -= 0.02) {
          let y1 = Math.sqrt(-2*p*x);
          if(isFinite(y1)) {
            let cx = toCanvasX(x + offsetX), cy1 = toCanvasY(y1 + offsetY);
            if(first) { 
              ctx.moveTo(cx, cy1); 
              first = false; 
            } else {
              ctx.lineTo(cx, cy1);
            }
          }
        }
        // ç»˜åˆ¶ä¸‹åŠæ”¯
        for(let x = endX; x <= startX; x += 0.02) {
          let y = -Math.sqrt(-2*p*x);
          if(isFinite(y)) {
            let cx = toCanvasX(x + offsetX), cy = toCanvasY(y + offsetY);
            ctx.lineTo(cx, cy);
          }
        }
      }
      ctx.stroke();
    } else {
      // xÂ²=2pyï¼Œå¹³ç§»åï¼š(x-h)Â²=2p(y-k)
      ctx.beginPath();
      let first = true;
      
      // æ‰©å¤§ç»˜åˆ¶èŒƒå›´ï¼Œç¡®ä¿è¦†ç›–æ•´ä¸ªè§†å›¾
      let viewRange = maxRange * 2;
      
      if(p > 0) {
        // p>0æ—¶ï¼Œå¼€å£å‘ä¸Šï¼Œä»é¡¶ç‚¹å¼€å§‹ç»˜åˆ¶
        let startY = 0; // æŠ›ç‰©çº¿çš„é¡¶ç‚¹åœ¨y=0
        let endY = viewRange;
        
        // ç»˜åˆ¶å³åŠæ”¯
        for(let y = startY; y <= endY; y += 0.02) {
          let x = Math.sqrt(2*p*y);
          if(isFinite(x)) {
            let cx1 = toCanvasX(x + offsetX), cy = toCanvasY(y + offsetY);
            if(first) { 
              ctx.moveTo(cx1, cy); 
              first = false; 
            } else {
              ctx.lineTo(cx1, cy);
            }
          }
        }
        // ç»˜åˆ¶å·¦åŠæ”¯
        for(let y = endY; y >= startY; y -= 0.02) {
          let x = -Math.sqrt(2*p*y);
          if(isFinite(x)) {
            let cx = toCanvasX(x + offsetX), cy = toCanvasY(y + offsetY);
            ctx.lineTo(cx, cy);
          }
        }
      } else {
        // p<0æ—¶ï¼Œå¼€å£å‘ä¸‹ï¼Œä»é¡¶ç‚¹å¼€å§‹ç»˜åˆ¶
        let startY = 0; // æŠ›ç‰©çº¿çš„é¡¶ç‚¹åœ¨y=0
        let endY = -viewRange;
        
        // ç»˜åˆ¶å³åŠæ”¯
        for(let y = startY; y >= endY; y -= 0.02) {
          let x = Math.sqrt(-2*p*y);
          if(isFinite(x)) {
            let cx1 = toCanvasX(x + offsetX), cy = toCanvasY(y + offsetY);
            if(first) { 
              ctx.moveTo(cx1, cy); 
              first = false; 
            } else {
              ctx.lineTo(cx1, cy);
            }
          }
        }
        // ç»˜åˆ¶å·¦åŠæ”¯
        for(let y = endY; y <= startY; y += 0.02) {
          let x = -Math.sqrt(-2*p*y);
          if(isFinite(x)) {
            let cx = toCanvasX(x + offsetX), cy = toCanvasY(y + offsetY);
            ctx.lineTo(cx, cy);
          }
        }
      }
      ctx.stroke();
    }
  });
  ctx.restore();
}

function drawHyperbolas() {
  ctx.save();
  ctx.strokeStyle = '#e67e22';
  ctx.lineWidth = 2;
  hyperbolas.forEach(hb => {
    // è®¡ç®—å‚æ•°åŒ–å±æ€§
    let x, y, a, b;
    try {
      if (hb.xExpr && hb.yExpr && hb.aExpr && hb.bExpr) {
        x = eval(substituteParameters(hb.xExpr));
        y = eval(substituteParameters(hb.yExpr));
        a = eval(substituteParameters(hb.aExpr));
        b = eval(substituteParameters(hb.bExpr));
      } else {
        x = hb.x;
        y = hb.y;
        a = hb.a;
        b = hb.b;
      }
    } catch {
      x = hb.x;
      y = hb.y;
      a = hb.a;
      b = hb.b;
    }
    
    if(hb.dir==='x') {
      // xÂ²/aÂ² - yÂ²/bÂ² = 1
      // å³æ”¯
      ctx.beginPath();
      let first = true;
      for(let t=-4;t<=4;t+=0.02) {
        let px = x + a*Math.cosh(t);
        let py = y + b*Math.sinh(t);
        let cx = toCanvasX(px), cy = toCanvasY(py);
        if(first) { ctx.moveTo(cx, cy); first=false; } else ctx.lineTo(cx, cy);
      }
      ctx.stroke();
      
      // å·¦æ”¯
      ctx.beginPath();
      first = true;
      for(let t=-4;t<=4;t+=0.02) {
        let px = x - a*Math.cosh(t);
        let py = y + b*Math.sinh(t);
        let cx = toCanvasX(px), cy = toCanvasY(py);
        if(first) { ctx.moveTo(cx, cy); first=false; } else ctx.lineTo(cx, cy);
      }
      ctx.stroke();
    } else {
      // yÂ²/aÂ² - xÂ²/bÂ² = 1
      // ä¸Šæ”¯
      ctx.beginPath();
      let first = true;
      for(let t=-4;t<=4;t+=0.02) {
        let py = y + a*Math.cosh(t);
        let px = x + b*Math.sinh(t);
        let cx = toCanvasX(px), cy = toCanvasY(py);
        if(first) { ctx.moveTo(cx, cy); first=false; } else ctx.lineTo(cx, cy);
      }
      ctx.stroke();
      
      // ä¸‹æ”¯
      ctx.beginPath();
      first = true;
      for(let t=-4;t<=4;t+=0.02) {
        let py = y - a*Math.cosh(t);
        let px = x + b*Math.sinh(t);
        let cx = toCanvasX(px), cy = toCanvasY(py);
        if(first) { ctx.moveTo(cx, cy); first=false; } else ctx.lineTo(cx, cy);
      }
      ctx.stroke();
    }
  });
  ctx.restore();
}

function drawPolars() {
  ctx.save();
  ctx.strokeStyle = '#16a085';
  ctx.lineWidth = 2;
  polars.forEach(pobj => {
    let expr = substituteParameters(pobj.expr);
    ctx.beginPath();
    let first = true;
    for(let theta=0;theta<=4*Math.PI;theta+=0.01) { // å¢åŠ ç»˜åˆ¶èŒƒå›´
      let r;
      try { 
        // æ›¿æ¢thetaå’Œå¸¸è§æ•°å­¦å‡½æ•°
        let evalExpr = expr
          .replace(/theta/g, theta)
          .replace(/th/g, theta)
          .replace(/sin/g, 'Math.sin')
          .replace(/cos/g, 'Math.cos')
          .replace(/tan/g, 'Math.tan')
          .replace(/\bpi\b/gi, 'Math.PI')
          .replace(/\bÏ€\b/g, 'Math.PI')
          .replace(/\be\b/g, 'Math.E')
          .replace(/\^/g, '**');
        r = eval(evalExpr); 
      } catch { continue; }
      if(typeof r !== 'number' || !isFinite(r)) continue;
      let x = r*Math.cos(theta), y = r*Math.sin(theta);
      let cx = toCanvasX(x), cy = toCanvasY(y);
      if(first) { ctx.moveTo(cx, cy); first=false; } else ctx.lineTo(cx, cy);
    }
    ctx.stroke();
  });
  ctx.restore();
}

// è®¡ç®—ç›´çº¿æ–¹ç¨‹å­—ç¬¦ä¸²
function getLineEquation(p1, p2) {
  let A = +(p2.y - p1.y).toFixed(2);
  let B = +(p1.x - p2.x).toFixed(2);
  let C = +(p2.x*p1.y - p1.x*p2.y).toFixed(2);
  let eq = '';
  if(A!==0) eq += (A===1?'':(A===-1?'-':A))+'x';
  if(B!==0) eq += (B>0&&A!==0?'+':'')+(B===1?'':(B===-1?'-':B))+'y';
  if(C!==0) eq += (C>0?'+':'')+C;
  eq += '=0';
  return eq.replace('1x','x').replace('1y','y').replace('+-','-');
}

function redraw() {
  ctx.clearRect(0,0,width,height);
  drawAxes();
  drawSegments();
  drawCircles();
  drawEllipses();
  drawParabolas();
  drawHyperbolas();
  drawPolars();
  drawFunctions();
  drawIntersectionLines();
  drawIntersectionPoints();
  drawPoints();
  renderSidebar();
}

function toCanvasX(x) { return origin.x + (x - panOffset.x) * scale; }
function toCanvasY(y) { return origin.y - (y - panOffset.y) * scale; }
function toMathX(cx) { return Math.round(((cx - origin.x) / scale + panOffset.x) * 10) / 10; }
function toMathY(cy) { return Math.round(((origin.y - cy) / scale + panOffset.y) * 10) / 10; }

function evaluateExpression(expr) {
  try {
    const substituted = substituteParameters(expr);
    return eval(substituted);
  } catch {
    return parseFloat(expr) || 0;
  }
}

function addPointByInput() {
  const xInput = document.getElementById('input-x').value;
  const yInput = document.getElementById('input-y').value;
  
  detectAndAddParameters([xInput, yInput]);
  
  const x = evaluateExpression(xInput);
  const y = evaluateExpression(yInput);
  
  if(isNaN(x) || isNaN(y)) { 
    alert('è¯·è¾“å…¥æœ‰æ•ˆçš„åæ ‡è¡¨è¾¾å¼ï¼'); 
    return; 
  }
  
  saveState(); // ä¿å­˜çŠ¶æ€ç”¨äºæ’¤é”€
  
  points.push({
    x: Math.round(x*10)/10, 
    y: Math.round(y*10)/10,
    xExpr: xInput,
    yExpr: yInput
  });
  updateIntersections();
  redraw();
}

function addSegmentByInput() {
  const x1Input = document.getElementById('input-x1').value;
  const y1Input = document.getElementById('input-y1').value;
  const x2Input = document.getElementById('input-x2').value;
  const y2Input = document.getElementById('input-y2').value;
  
  detectAndAddParameters([x1Input, y1Input, x2Input, y2Input]);
  
  const x1 = evaluateExpression(x1Input);
  const y1 = evaluateExpression(y1Input);
  const x2 = evaluateExpression(x2Input);
  const y2 = evaluateExpression(y2Input);
  
  if([x1,y1,x2,y2].some(v=>isNaN(v))) { 
    alert('è¯·è¾“å…¥æœ‰æ•ˆçš„åæ ‡è¡¨è¾¾å¼ï¼'); 
    return; 
  }
  
  saveState(); // ä¿å­˜çŠ¶æ€ç”¨äºæ’¤é”€
  
  let p1 = findOrCreatePoint(Math.round(x1*10)/10, Math.round(y1*10)/10);
  let p2 = findOrCreatePoint(Math.round(x2*10)/10, Math.round(y2*10)/10);
  segments.push({p1, p2});
  updateIntersections();
  redraw();
}

function addCircleByInput() {
  const xInput = document.getElementById('input-x').value;
  const yInput = document.getElementById('input-y').value;
  const rInput = document.getElementById('input-r').value;
  
  detectAndAddParameters([xInput, yInput, rInput]);
  
  const x = evaluateExpression(xInput);
  const y = evaluateExpression(yInput);
  const r = evaluateExpression(rInput);
  
  if(isNaN(x) || isNaN(y) || isNaN(r) || r<=0) { 
    alert('è¯·è¾“å…¥æœ‰æ•ˆçš„åœ†å¿ƒåæ ‡å’Œæ­£æ•°åŠå¾„è¡¨è¾¾å¼ï¼'); 
    return; 
  }
  
  saveState(); // ä¿å­˜çŠ¶æ€ç”¨äºæ’¤é”€
  
  let center = findOrCreatePoint(Math.round(x*10)/10, Math.round(y*10)/10);
  circles.push({
    x: Math.round(x*10)/10, 
    y: Math.round(y*10)/10, 
    r: Math.round(r*10)/10, 
    centerRef: center,
    xExpr: xInput,
    yExpr: yInput,
    rExpr: rInput
  });
  updateIntersections();
  redraw();
}

function addEllipseByInput() {
  const xInput = document.getElementById('input-x').value;
  const yInput = document.getElementById('input-y').value;
  const aInput = document.getElementById('input-a').value;
  const bInput = document.getElementById('input-b').value;
  
  detectAndAddParameters([xInput, yInput, aInput, bInput]);
  
  const x = evaluateExpression(xInput);
  const y = evaluateExpression(yInput);
  const a = evaluateExpression(aInput);
  const b = evaluateExpression(bInput);
  
  if(isNaN(x)||isNaN(y)||isNaN(a)||isNaN(b)||a<=0||b<=0) {
    alert('è¯·è¾“å…¥æœ‰æ•ˆçš„ä¸­å¿ƒåæ ‡å’Œæ­£æ•°aã€bè¡¨è¾¾å¼ï¼'); 
    return;
  }
  
  saveState(); // ä¿å­˜çŠ¶æ€ç”¨äºæ’¤é”€
  
  ellipses.push({
    x: Math.round(x*10)/10, 
    y: Math.round(y*10)/10, 
    a: Math.round(a*10)/10, 
    b: Math.round(b*10)/10,
    xExpr: xInput,
    yExpr: yInput,
    aExpr: aInput,
    bExpr: bInput,
    raw: `æ¤­åœ† ä¸­å¿ƒ(${xInput},${yInput}) a=${aInput} b=${bInput}`
  });
  redraw();
}

function addParabolaByInput() {
  const type = document.getElementById('parabola-type').value;
  const pInput = document.getElementById('input-p').value;
  
  detectAndAddParameters([pInput]);
  
  const p = evaluateExpression(pInput);
  
  if(isNaN(p) || p === 0) {
    alert('è¯·è¾“å…¥æœ‰æ•ˆçš„å‚æ•°pè¡¨è¾¾å¼ï¼ˆéé›¶ï¼‰ï¼'); 
    return;
  }
  
  saveState(); // ä¿å­˜çŠ¶æ€ç”¨äºæ’¤é”€
  
  parabolas.push({
    type: type,
    p: Math.round(p*10)/10,
    pExpr: pInput,
    raw: `æŠ›ç‰©çº¿ ${type==='y2'?'yÂ²=2px':'xÂ²=2py'} p=${pInput}`
  });
  redraw();
}

function addHyperbolaByInput() {
  const xInput = document.getElementById('input-x').value;
  const yInput = document.getElementById('input-y').value;
  const aInput = document.getElementById('input-a').value;
  const bInput = document.getElementById('input-b').value;
  const dir = document.getElementById('hyperbola-type').value;
  
  detectAndAddParameters([xInput, yInput, aInput, bInput]);
  
  const x = evaluateExpression(xInput);
  const y = evaluateExpression(yInput);
  const a = evaluateExpression(aInput);
  const b = evaluateExpression(bInput);
  
  if(isNaN(x)||isNaN(y)||isNaN(a)||isNaN(b)||a<=0||b<=0) {
    alert('è¯·è¾“å…¥æœ‰æ•ˆçš„ä¸­å¿ƒåæ ‡å’Œæ­£æ•°aã€bè¡¨è¾¾å¼ï¼'); 
    return;
  }
  
  saveState(); // ä¿å­˜çŠ¶æ€ç”¨äºæ’¤é”€
  
  hyperbolas.push({
    x: Math.round(x*10)/10,
    y: Math.round(y*10)/10,
    a: Math.round(a*10)/10,
    b: Math.round(b*10)/10,
    dir: dir,
    xExpr: xInput,
    yExpr: yInput,
    aExpr: aInput,
    bExpr: bInput,
    raw: `åŒæ›²çº¿ ä¸­å¿ƒ(${xInput},${yInput}) a=${aInput} b=${bInput} ${dir==='x'?'xè½´':'yè½´'}æ–¹å‘`
  });
  redraw();
}

function addPolarByInput() {
  let polarStr = document.getElementById('input-polar').value;
  if(!polarStr) { alert('è¯·è¾“å…¥æåæ ‡æ–¹ç¨‹ï¼'); return; }
  
  detectAndAddParameters([polarStr]);
  
  // é¢„å¤„ç†è¡¨è¾¾å¼
  let expr = polarStr.trim().toLowerCase();
  if(expr.startsWith('r=')) expr = expr.slice(2);
  
  // æ›¿æ¢å¸¸è§çš„æ•°å­¦ç¬¦å·
  expr = expr.replace(/\^/g, '**')
             .replace(/\bpi\b/gi, 'Math.PI')
             .replace(/\bÏ€\b/g, 'Math.PI')
             .replace(/\be\b/g, 'Math.E');
  
  saveState(); // ä¿å­˜çŠ¶æ€ç”¨äºæ’¤é”€
  
  polars.push({
    expr: expr,
    raw: polarStr
  });
  redraw();
}

function addFunction() {
  let funcStr = document.getElementById('input-func').value;
  if(!funcStr) return;
  
  detectAndAddParameters([funcStr]);
  
  let expr = funcStr.trim().toLowerCase();
  if(expr.startsWith('y=')) expr = expr.slice(2);
  expr = expr.replace(/\^/g, '**')
             .replace(/sin/g, 'Math.sin')
             .replace(/cos/g, 'Math.cos')
             .replace(/tan/g, 'Math.tan')
             .replace(/exp/g, 'Math.exp')
             .replace(/log/g, 'Math.log10')
             .replace(/ln/g, 'Math.log')
             .replace(/abs/g, 'Math.abs')
             .replace(/\bpi\b/gi, 'Math.PI')
             .replace(/\bÏ€\b/g, 'Math.PI')
             .replace(/\be\b/g, 'Math.E');
  if(!Math.log10) Math.log10 = x => Math.log(x)/Math.LN10;
  
  saveState(); // ä¿å­˜çŠ¶æ€ç”¨äºæ’¤é”€
  
  functions.push({expr, raw: funcStr});
  updateIntersections();
  redraw();
}

function findOrCreatePoint(x, y) {
  let pt = points.find(p=>Math.abs(p.x-x)<1e-6 && Math.abs(p.y-y)<1e-6);
  if(!pt) { pt = {x, y}; points.push(pt); }
  return pt;
}

function toggleGrid() {
  showGrid = document.getElementById('toggle-grid').checked;
  redraw();
}

function confirmLine() {
  if(lineSelectPoints.length === 2 && lineSelectPoints[0] !== lineSelectPoints[1]) {
    saveState(); // ä¿å­˜çŠ¶æ€ç”¨äºæ’¤é”€
    intersectionLines.push({p1: lineSelectPoints[0], p2: lineSelectPoints[1]});
  }
  lineSelectPoints = [];
  lineSelectActive = false;
  switchMode('point');
  redraw();
}

function cancelLineSelect() {
  lineSelectPoints = [];
  lineSelectActive = true;
  renderInputArea();
  redraw();
}

canvas.onmousedown = function(e) {
  const {x, y} = getMouseMathPos(e);
  
  // ç‚¹æ¨¡å¼ä¸‹ç‚¹å‡»ç”»å¸ƒå³æ·»åŠ ç‚¹
  if(mode==='point') {
    saveState(); // ä¿å­˜çŠ¶æ€ç”¨äºæ’¤é”€
    points.push({x: Math.round(x*10)/10, y: Math.round(y*10)/10});
    updateIntersections();
    redraw();
    return;
  }
  
  // ç§»åŠ¨æ¨¡å¼ï¼šåªå¤„ç†ç”»å¸ƒç§»åŠ¨å’Œç¼©æ”¾
  if(mode==='move') {
    if(e.shiftKey) {
      scalingCanvas = true;
    } else {
      draggingCanvas = true;
    }
    lastMouse = {x: e.clientX, y: e.clientY};
    canvas.style.cursor = scalingCanvas ? 'ns-resize' : 'grabbing';
    return;
  }
  
  // æ‹–åŠ¨æ¨¡å¼æˆ–å…¶ä»–æ¨¡å¼ï¼šå¤„ç†å‡ ä½•å¯¹è±¡çš„é€‰ä¸­å’Œæ‹–åŠ¨
  let found = false;
  
  // é€‰ä¸­ç‚¹
  for(let i=0;i<points.length;i++) {
    let pt = points[i];
    if(dist(pt, {x, y}) < 0.3) {
      selectedPointIdx = i;
      if(mode==='drag') {
        draggingPoint = pt;
        dragOffset.x = pt.x - x;
        dragOffset.y = pt.y - y;
      }
      found = true;
      redraw();
      
      // ä½œç›´çº¿æ¨¡å¼ä¸‹é€‰æ‹©ç‚¹
      if(mode==='line' && lineSelectActive && lineSelectPoints.length < 2 && !lineSelectPoints.includes(pt)) {
        lineSelectPoints.push(pt);
        renderInputArea();
        redraw();
      }
      return;
    }
  }
  
  // é€‰ä¸­åœ†å¿ƒ
  if(mode==='drag') {
    for(let c of circles) {
      if(dist({x, y}, {x: c.x, y: c.y}) < 0.5) {
        draggingPoint = c.centerRef;
        dragOffset.x = c.x - x;
        dragOffset.y = c.y - y;
        found = true;
        break;
      }
    }
  }
  
  // é€‰ä¸­æ›²çº¿è¿›è¡Œæ‹–åŠ¨
  if(mode==='drag' && !found) {
    // æ£€æµ‹æŠ›ç‰©çº¿
    for(let i = 0; i < parabolas.length; i++) {
      if(isPointNearParabola({x, y}, parabolas[i])) {
        draggingCurve = parabolas[i];
        curveType = 'parabola';
        selectedParabolaIdx = i;
        
        // è®°å½•åˆå§‹æ‹–åŠ¨ä½ç½®å’Œå½“å‰åç§»
        dragOffset.x = x;
        dragOffset.y = y;
        dragOffset.initialOffsetX = parabolas[i].dragOffset ? parabolas[i].dragOffset.x : 0;
        dragOffset.initialOffsetY = parabolas[i].dragOffset ? parabolas[i].dragOffset.y : 0;
        
        // è®°å½•åˆå§‹çŠ¶æ€
        if (!parabolas[i].originalState) {
          parabolas[i].originalState = {
            p: parabolas[i].p,
            pExpr: parabolas[i].pExpr,
            type: parabolas[i].type,
            raw: parabolas[i].raw
          };
        }
        found = true;
        redraw();
        break;
      }
    }
  }
  
  // ä½œç›´çº¿ï¼šäº¤ç‚¹ä¹Ÿå¯é€‰
  if(mode==='line' && lineSelectActive && lineSelectPoints.length < 2) {
    for(let i=0;i<intersectionPoints.length;i++) {
      let pt = intersectionPoints[i];
      if(dist(pt, {x, y}) < 0.3 && !lineSelectPoints.includes(pt)) {
        lineSelectPoints.push(pt);
        renderInputArea();
        redraw();
        return;
      }
    }
  }
};

canvas.onmousemove = function(e) {
  if(draggingPoint) {
    const {x, y} = getMouseMathPos(e);
    draggingPoint.x = Math.round((x + dragOffset.x)*10)/10;
    draggingPoint.y = Math.round((y + dragOffset.y)*10)/10;
    
    // æ ‡è®°ç‚¹å·²è¢«æ‹–åŠ¨
    draggingPoint.isDragged = true;
    
    // å¦‚æœæ˜¯å‚æ•°åŒ–çš„ç‚¹ï¼Œæ›´æ–°å¯¹åº”çš„å‚æ•°å€¼
    if(draggingPoint.xExpr && draggingPoint.yExpr) {
      updateParametersFromPoint(draggingPoint);
    }
    
    for(let c of circles) {
      if(c.centerRef === draggingPoint) {
        c.x = draggingPoint.x;
        c.y = draggingPoint.y;
      }
    }
    updateIntersections();
    redraw();
  } else if(draggingCurve) {
    const {x, y} = getMouseMathPos(e);
    
    if(curveType === 'parabola') {
      // è®¡ç®—ç›¸å¯¹äºåˆå§‹ç‚¹å‡»ä½ç½®çš„åç§»é‡
      const dx = (x - dragOffset.x) + dragOffset.initialOffsetX;
      const dy = (y - dragOffset.y) + dragOffset.initialOffsetY;
      
      // æ ‡è®°æ›²çº¿å·²è¢«æ‹–åŠ¨
      draggingCurve.isDragged = true;
      draggingCurve.dragOffset = {x: dx, y: dy};
      
      // ç”Ÿæˆå¹³ç§»åçš„æ–¹ç¨‹
      generateTransformedEquation(draggingCurve);
    }
    
    redraw();
  } else if(draggingCanvas) {
    let dx = (e.clientX - lastMouse.x)/scale;
    let dy = (e.clientY - lastMouse.y)/scale;
    panOffset.x -= dx;
    panOffset.y += dy;
    lastMouse = {x: e.clientX, y: e.clientY};
    redraw();
  } else if(scalingCanvas) {
    let dy = (e.clientY - lastMouse.y);
    let factor = 1 - dy*0.01;
    let newScale = scale*factor;
    scale = newScale;
    lastMouse = {x: e.clientX, y: e.clientY};
    redraw();
  }
};

canvas.onmouseup = function() {
  draggingPoint = null;
  draggingCurve = null;
  curveType = null;
  
  if(draggingCanvas || scalingCanvas) {
    draggingCanvas = false;
    scalingCanvas = false;
    // æ ¹æ®å½“å‰æ¨¡å¼è®¾ç½®æ­£ç¡®çš„å…‰æ ‡
    if(mode==='move') {
      canvas.style.cursor = 'grab';
    } else if(mode==='drag') {
      canvas.style.cursor = 'pointer';
    } else if(mode==='point') {
      canvas.style.cursor = 'crosshair';
    } else if(mode==='line') {
      canvas.style.cursor = 'pointer';
    } else {
      canvas.style.cursor = 'default';
    }
  }
};

// æ–°å¢ï¼šé¼ æ ‡ç¦»å¼€canvasæ—¶è‡ªåŠ¨æ¾æ‰‹
canvas.addEventListener('mouseleave', function() {
  draggingCanvas = false;
  scalingCanvas = false;
  // æ ¹æ®å½“å‰æ¨¡å¼è®¾ç½®æ­£ç¡®çš„å…‰æ ‡
  if(mode==='move') {
    canvas.style.cursor = 'grab';
  } else if(mode==='drag') {
    canvas.style.cursor = 'pointer';
  } else if(mode==='point') {
    canvas.style.cursor = 'crosshair';
  } else if(mode==='line') {
    canvas.style.cursor = 'pointer';
  } else {
    canvas.style.cursor = 'default';
  }
});

// é¼ æ ‡æ»šè½®äº‹ä»¶ç›‘å¬ - ä»…åœ¨canvasåŒºåŸŸå†…ç¼©æ”¾
canvas.addEventListener('wheel', function(e) {
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;
  
  // æ£€æŸ¥é¼ æ ‡æ˜¯å¦åœ¨canvaså†…
  if (mouseX >= 0 && mouseX <= canvas.width && mouseY >= 0 && mouseY <= canvas.height) {
    e.preventDefault(); // åªåœ¨canvaså†…é˜»æ­¢é»˜è®¤æ»šåŠ¨è¡Œä¸º
    
    // è·å–é¼ æ ‡åœ¨æ•°å­¦åæ ‡ç³»ä¸­çš„ä½ç½®
    const mathPos = getMouseMathPos(e);
    
    // ç¼©æ”¾å› å­
    const scaleFactor = e.deltaY > 0 ? 0.9 : 1.1;
    const oldScale = scale;
    scale *= scaleFactor;
    
    // é™åˆ¶ç¼©æ”¾èŒƒå›´ï¼Œé¿å…è¿‡åº¦ç¼©æ”¾
    scale = Math.max(5, Math.min(scale, 500));
    
    // è®¡ç®—ç¼©æ”¾åéœ€è¦è°ƒæ•´çš„å¹³ç§»é‡ï¼Œä½¿é¼ æ ‡ä½ç½®ä¿æŒä¸å˜
    const scaleRatio = scale / oldScale;
    panOffset.x = mathPos.x - (mathPos.x - panOffset.x) / scaleRatio;
    panOffset.y = mathPos.y - (mathPos.y - panOffset.y) / scaleRatio;
    
    redraw();
  }
  // å¦‚æœé¼ æ ‡ä¸åœ¨canvaså†…ï¼Œä¸é˜»æ­¢é»˜è®¤è¡Œä¸ºï¼Œå…è®¸é¡µé¢æ»šåŠ¨
}, { passive: false });

function getMouseMathPos(e) {
  const rect = canvas.getBoundingClientRect();
  const cx = e.clientX - rect.left;
  const cy = e.clientY - rect.top;
  return { x: ((cx-origin.x)/scale + panOffset.x), y: ((origin.y-cy)/scale + panOffset.y) };
}

function dist(p1, p2) { return Math.hypot(p1.x-p2.x, p1.y-p2.y); }

// æ£€æµ‹ç‚¹æ˜¯å¦é è¿‘æŠ›ç‰©çº¿
function isPointNearParabola(point, parabola) {
  let p;
  try {
    if (parabola.pExpr) {
      p = eval(substituteParameters(parabola.pExpr));
    } else {
      p = parabola.p;
    }
  } catch {
    p = parabola.p;
  }
  
  const threshold = 1.0; // å¢å¤§è·ç¦»é˜ˆå€¼ï¼Œä¾¿äºé€‰ä¸­
  const {x, y} = point;
  
  if(parabola.type === 'y2') {
    // yÂ²=2pxï¼Œè®¡ç®—ç‚¹åˆ°æŠ›ç‰©çº¿çš„è·ç¦»
    if(p > 0 && x >= -threshold) {
      const yExpected = x >= 0 ? Math.sqrt(2*p*Math.abs(x)) : 0;
      return Math.abs(Math.abs(y) - yExpected) < threshold;
    } else if(p < 0 && x <= threshold) {
      const yExpected = x <= 0 ? Math.sqrt(-2*p*Math.abs(x)) : 0;
      return Math.abs(Math.abs(y) - yExpected) < threshold;
    }
  } else {
    // xÂ²=2pyï¼Œè®¡ç®—ç‚¹åˆ°æŠ›ç‰©çº¿çš„è·ç¦»
    if(p > 0 && y >= -threshold) {
      const xExpected = y >= 0 ? Math.sqrt(2*p*Math.abs(y)) : 0;
      return Math.abs(Math.abs(x) - xExpected) < threshold;
    } else if(p < 0 && y <= threshold) {
      const xExpected = y <= 0 ? Math.sqrt(-2*p*Math.abs(y)) : 0;
      return Math.abs(Math.abs(x) - xExpected) < threshold;
    }
  }
  return false;
}

function resetAll() {
  if (confirm('ç¡®å®šè¦é‡ç½®æ‰€æœ‰å†…å®¹å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚')) {
    saveState(); // ä¿å­˜çŠ¶æ€ç”¨äºæ’¤é”€
    points = [];
    segments = [];
    circles = [];
    ellipses = [];
    parabolas = [];
    hyperbolas = [];
    polars = [];
    functions = [];
    intersectionPoints = [];
    intersectionLines = [];
    panOffset = {x:0, y:0};
    scale = 40;
    selectedPointIdx = null;
    selectedSegmentIdx = null;
    selectedCircleIdx = null;
    selectedFunctionIdx = null;
    redraw();
  }
}

function updateIntersections() {
  intersectionPoints = [];
  for(let i=0;i<segments.length;i++){
    for(let j=i+1;j<segments.length;j++){
      let pt = segmentIntersection(segments[i], segments[j]);
      if(pt) intersectionPoints.push(pt);
    }
  }
  for(let seg of segments) {
    for(let c of circles) {
      let pts = segmentCircleIntersection(seg, c);
      pts.forEach(pt=>intersectionPoints.push(pt));
    }
  }
  for(let i=0;i<circles.length;i++){
    for(let j=i+1;j<circles.length;j++){
      let pts = circleCircleIntersection(circles[i], circles[j]);
      pts.forEach(pt=>intersectionPoints.push(pt));
    }
  }
}

function segmentIntersection(s1, s2) {
  let {x:x1, y:y1} = s1.p1, {x:x2, y:y2} = s1.p2;
  let {x:x3, y:y3} = s2.p1, {x:x4, y:y4} = s2.p2;
  let denom = (x1-x2)*(y3-y4)-(y1-y2)*(x3-x4);
  if(denom===0) return null;
  let px = ((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4))/denom;
  let py = ((x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/denom;
  if(
    Math.min(x1,x2)-1e-6<=px && px<=Math.max(x1,x2)+1e-6 &&
    Math.min(y1,y2)-1e-6<=py && py<=Math.max(y1,y2)+1e-6 &&
    Math.min(x3,x4)-1e-6<=px && px<=Math.max(x3,x4)+1e-6 &&
    Math.min(y3,y4)-1e-6<=py && py<=Math.max(y3,y4)+1e-6
  ) return {x:Math.round(px*10)/10, y:Math.round(py*10)/10};
  return null;
}

function segmentCircleIntersection(seg, c) {
  let {x:x1, y:y1} = seg.p1, {x:x2, y:y2} = seg.p2;
  let {x:cx, y:cy, r} = c;
  let dx = x2-x1, dy = y2-y1;
  let fx = x1-cx, fy = y1-cy;
  let a = dx*dx+dy*dy;
  let b = 2*(fx*dx+fy*dy);
  let c0 = fx*fx+fy*fy-r*r;
  let D = b*b-4*a*c0;
  let pts = [];
  if(D<0) return pts;
  D = Math.sqrt(D);
  let t1 = (-b+D)/(2*a), t2 = (-b-D)/(2*a);
  [t1,t2].forEach(t=>{
    if(t>=0&&t<=1) {
      let px = x1+dx*t, py = y1+dy*t;
      pts.push({x:Math.round(px*10)/10, y:Math.round(py*10)/10});
    }
  });
  return pts;
}

function circleCircleIntersection(c1, c2) {
  let {x:x1, y:y1, r:r1} = c1, {x:x2, y:y2, r:r2} = c2;
  let dx = x2-x1, dy = y2-y1;
  let d = Math.hypot(dx, dy);
  if(d>r1+r2||d<Math.abs(r1-r2)||d===0) return [];
  let a = (r1*r1-r2*r2+d*d)/(2*d);
  let h = Math.sqrt(r1*r1-a*a);
  let xm = x1+a*dx/d, ym = y1+a*dy/d;
  let xs1 = xm+h*dy/d, ys1 = ym-h*dx/d;
  let xs2 = xm-h*dy/d, ys2 = ym+h*dx/d;
  return [ {x:Math.round(xs1*10)/10, y:Math.round(ys1*10)/10}, {x:Math.round(xs2*10)/10, y:Math.round(ys2*10)/10} ];
}

function renderSidebar() {
  // ç‚¹
  let pointList = document.getElementById('point-list');
  pointList.innerHTML = '';
  points.forEach((pt, idx) => {
    let li = document.createElement('li');
    let displayX = pt.xExpr || pt.x.toFixed(1);
    let displayY = pt.yExpr || pt.y.toFixed(1);
    
    // æ˜¾ç¤ºæ‹–åŠ¨åçš„å®é™…åæ ‡
    let draggedInfo = '';
    if (pt.isDragged) {
      draggedInfo = ` â†’ (${pt.x.toFixed(1)}, ${pt.y.toFixed(1)})`;
    }
    
    li.innerHTML = `
      <span class="item-text">${String.fromCharCode(65+idx)} (${displayX}, ${displayY})${draggedInfo}</span>
      <div style="display: inline-flex; gap: 2px;">
        ${pt.isDragged ? `<button class="delete-btn" onclick="restorePoint(${idx})" title="å¤åŸæ­¤ç‚¹" style="background: #27ae60;">â†¶</button>` : ''}
        <button class="delete-btn" onclick="deletePoint(${idx})" title="åˆ é™¤ç‚¹">Ã—</button>
      </div>
    `;
    
    if(selectedPointIdx===idx) li.classList.add('selected');
    li.querySelector('.item-text').onclick = () => { selectedPointIdx = idx; redraw(); };
    pointList.appendChild(li);
  });
  
  // çº¿æ®µ
  let segList = document.getElementById('segment-list');
  segList.innerHTML = '';
  segments.forEach((seg, idx) => {
    let i1 = points.indexOf(seg.p1), i2 = points.indexOf(seg.p2);
    let li = document.createElement('li');
    li.innerHTML = `
      <span class="item-text">çº¿æ®µ ${String.fromCharCode(65+i1)}${String.fromCharCode(65+i2)}</span>
      <button class="delete-btn" onclick="deleteSegment(${idx})" title="åˆ é™¤çº¿æ®µ">Ã—</button>
    `;
    segList.appendChild(li);
  });
  
  // ç›´çº¿
  let lineList = document.getElementById('line-list');
  lineList.innerHTML = '';
  intersectionLines.forEach((line, idx) => {
    let eq = getLineEquation(line.p1, line.p2);
    let i1 = points.indexOf(line.p1), i2 = points.indexOf(line.p2);
    let label = '';
    if(i1>=0 && i2>=0) label = `ç›´çº¿ ${String.fromCharCode(65+i1)}${String.fromCharCode(65+i2)}`;
    else label = `ç›´çº¿ (${line.p1.x.toFixed(1)},${line.p1.y.toFixed(1)})-(${line.p2.x.toFixed(1)},${line.p2.y.toFixed(1)})`;
    
    let li = document.createElement('li');
    li.innerHTML = `
      <span class="item-text">${label} ${eq}</span>
      <button class="delete-btn" onclick="deleteLine(${idx})" title="åˆ é™¤ç›´çº¿">Ã—</button>
    `;
    lineList.appendChild(li);
  });
  
  // åœ†
  let circleList = document.getElementById('circle-list');
  circleList.innerHTML = '';
  circles.forEach((c, idx) => {
    let rDisplay = c.rExpr || c.r.toFixed(1);
    let li = document.createElement('li');
    // åœ†ç¼–å· Oâ‚ã€Oâ‚‚ã€Oâ‚ƒ ...
    let circleNum = idx + 1;
    li.innerHTML = `
      <span class="item-text">åœ† O<sub>${circleNum}</sub> (r=${rDisplay})</span>
      <button class="delete-btn" onclick="deleteCircle(${idx})" title="åˆ é™¤åœ†">Ã—</button>
    `;
    if(selectedCircleIdx === idx) li.classList.add('selected');
    li.querySelector('.item-text').onclick = () => {
      if(selectedCircleIdx === idx) {
        selectedCircleIdx = null;
      } else {
        selectedCircleIdx = idx;
      }
      redraw();
    };
    circleList.appendChild(li);
  });
  
  // å‡½æ•°/æ–¹ç¨‹
  let funcList = document.getElementById('function-list');
  funcList.innerHTML = '';
  
  // å‡½æ•°/æ–¹ç¨‹ç¼–å· fâ‚(x)ã€fâ‚‚(x)...
  functions.forEach((f, idx) => {
    let li = document.createElement('li');
    let funcNum = idx + 1;
    let display = '';
    if (f.raw && /^y\s*=/.test(f.raw.trim())) {
      display = `f<sub>${funcNum}</sub>(x) = ${f.raw.trim().replace(/^y\s*=/, '')}`;
    } else if (f.raw && /^x\s*=/.test(f.raw.trim())) {
      display = `f<sub>${funcNum}</sub>(y) = ${f.raw.trim().replace(/^x\s*=/, '')}`;
    } else if (f.raw) {
      display = `f<sub>${funcNum}</sub>: ${f.raw}`;
    } else {
      display = `f<sub>${funcNum}</sub>(x)`;
    }
    li.innerHTML = `
      <span class="item-text">${display}</span>
      <button class="delete-btn" onclick="deleteFunction(${idx})" title="åˆ é™¤å‡½æ•°">Ã—</button>
    `;
    if(selectedFunctionIdx === idx) li.classList.add('selected');
    li.querySelector('.item-text').onclick = () => { selectedFunctionIdx = idx; redraw(); };
    funcList.appendChild(li);
  });
  
  // æ¤­åœ†
  ellipses.forEach((e, idx) => {
    let li = document.createElement('li');
    li.innerHTML = `
      <span class="item-text">${e.raw || 'æ¤­åœ†'}</span>
      <button class="delete-btn" onclick="deleteEllipse(${idx})" title="åˆ é™¤æ¤­åœ†">Ã—</button>
    `;
    funcList.appendChild(li);
  });
  
  // æŠ›ç‰©çº¿
  parabolas.forEach((p, idx) => {
    let li = document.createElement('li');
    
    // æ„å»ºæ˜¾ç¤ºæ–‡æœ¬
    let displayText = p.raw || 'æŠ›ç‰©çº¿';
    if (p.isDragged && p.transformedEquation) {
      displayText += `<br><span style="color: #27ae60; font-size: 12px;">â†’ ${p.transformedEquation}</span>`;
    }
    
    li.innerHTML = `
      <span class="item-text">${displayText}</span>
      <div style="display: inline-flex; gap: 2px;">
        ${p.isDragged ? `<button class="delete-btn" onclick="restoreParabola(${idx})" title="å¤åŸæ­¤æŠ›ç‰©çº¿" style="background: #27ae60;">â†¶</button>` : ''}
        <button class="delete-btn" onclick="deleteParabola(${idx})" title="åˆ é™¤æŠ›ç‰©çº¿">Ã—</button>
      </div>
    `;
    funcList.appendChild(li);
  });
  
  // åŒæ›²çº¿
  hyperbolas.forEach((h, idx) => {
    let li = document.createElement('li');
    li.innerHTML = `
      <span class="item-text">${h.raw || 'åŒæ›²çº¿'}</span>
      <button class="delete-btn" onclick="deleteHyperbola(${idx})" title="åˆ é™¤åŒæ›²çº¿">Ã—</button>
    `;
    funcList.appendChild(li);
  });
  
  // æåæ ‡
  polars.forEach((p, idx) => {
    let li = document.createElement('li');
    li.innerHTML = `
      <span class="item-text">${p.raw || 'æåæ ‡'}</span>
      <button class="delete-btn" onclick="deletePolar(${idx})" title="åˆ é™¤æåæ ‡æ›²çº¿">Ã—</button>
    `;
    funcList.appendChild(li);
  });
}

// åˆå§‹åŒ–
switchMode('move'); // é»˜è®¤é€‰ä¸­ç§»åŠ¨æ¨¡å¼
renderParameterControls();
updateIntersections();
redraw();

// é”®ç›˜äº‹ä»¶ç›‘å¬
document.addEventListener('keydown', function(e) {
  // Ctrl+Z æ’¤é”€
  if (e.ctrlKey && e.key === 'z') {
    e.preventDefault();
    undo();
  }
  
  // æ–¹å‘é”®æ§åˆ¶é€‰ä¸­çš„æ›²çº¿å¹³ç§»
  if (mode === 'drag' && (selectedParabolaIdx !== null || selectedPointIdx !== null)) {
    const step = 0.1; // æ¯æ¬¡ç§»åŠ¨çš„æ­¥é•¿
    let moved = false;
    
    switch(e.key) {
      case 'ArrowUp':
        e.preventDefault();
        if (selectedParabolaIdx !== null) {
          moveParabola(selectedParabolaIdx, 0, step);
          moved = true;
        } else if (selectedPointIdx !== null) {
          movePoint(selectedPointIdx, 0, step);
          moved = true;
        }
        break;
      case 'ArrowDown':
        e.preventDefault();
        if (selectedParabolaIdx !== null) {
          moveParabola(selectedParabolaIdx, 0, -step);
          moved = true;
        } else if (selectedPointIdx !== null) {
          movePoint(selectedPointIdx, 0, -step);
          moved = true;
        }
        break;
      case 'ArrowLeft':
        e.preventDefault();
        if (selectedParabolaIdx !== null) {
          moveParabola(selectedParabolaIdx, -step, 0);
          moved = true;
        } else if (selectedPointIdx !== null) {
          movePoint(selectedPointIdx, -step, 0);
          moved = true;
        }
        break;
      case 'ArrowRight':
        e.preventDefault();
        if (selectedParabolaIdx !== null) {
          moveParabola(selectedParabolaIdx, step, 0);
          moved = true;
        } else if (selectedPointIdx !== null) {
          movePoint(selectedPointIdx, step, 0);
          moved = true;
        }
        break;
    }
    
    if (moved) {
      redraw();
    }
  }
});

// å…¨å±æŒ‰é’®JS
const fullscreenBtn = document.getElementById('fullscreen-btn');
fullscreenBtn.onclick = function() {
  const el = document.documentElement;
  if (!document.fullscreenElement) {
    el.requestFullscreen();
  } else {
    document.exitFullscreen();
  }
};

document.addEventListener('fullscreenchange', function() {
  if(document.fullscreenElement) {
    fullscreenBtn.innerText = 'â›¶';
    fullscreenBtn.title = 'é€€å‡ºå…¨å±';
  } else {
    fullscreenBtn.innerText = 'â›¶';
    fullscreenBtn.title = 'å…¨å±';
  }
});

// å•ä¸ªå‚æ•°é‡ç½®ä¸º0
function resetParameter(name) {
  if (parameters.hasOwnProperty(name)) {
    parameters[name] = 0;
    renderParameterControls();
    redraw();
  }
}

// è§†è§’å¤ä½æŒ‰é’®é€»è¾‘
document.getElementById('reset-view-btn').onclick = function() {
  panOffset = {x:0, y:0};
  scale = 40;
  redraw();
};
</script>
</body>
</html>
